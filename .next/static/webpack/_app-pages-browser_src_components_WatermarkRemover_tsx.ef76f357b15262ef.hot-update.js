"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_WatermarkRemover_tsx",{

/***/ "(app-pages-browser)/./src/lib/core/watermarkEngine.ts":
/*!*****************************************!*\
  !*** ./src/lib/core/watermarkEngine.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WatermarkEngine: () => (/* binding */ WatermarkEngine),\n/* harmony export */   calculateWatermarkPosition: () => (/* binding */ calculateWatermarkPosition),\n/* harmony export */   detectWatermarkConfig: () => (/* binding */ detectWatermarkConfig),\n/* harmony export */   detectWatermarkProvider: () => (/* binding */ detectWatermarkProvider)\n/* harmony export */ });\n/* harmony import */ var _alphaMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alphaMap */ \"(app-pages-browser)/./src/lib/core/alphaMap.ts\");\n/* harmony import */ var _blendModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blendModes */ \"(app-pages-browser)/./src/lib/core/blendModes.ts\");\n/**\r\n * Watermark Engine - Main Module\r\n * @fileoverview Coordinates watermark detection, alpha map calculation, and removal operations\r\n * @module watermarkEngine\r\n */ \n\n// Import assets as static URLs\n// Note: In Next.js, we'll use dynamic imports for better compatibility\nconst BG_48_URL = '/bg_48.png';\nconst BG_96_URL = '/bg_96.png';\n// Nano Banana watermark patterns (to be added)\nconst NANO_BANANA_48_URL = '/nano_banana_48.png';\nconst NANO_BANANA_96_URL = '/nano_banana_96.png';\n/**\r\n * Detect watermark provider from image metadata or patterns\r\n * \r\n * @param image - Image element to analyze\r\n * @returns Detected provider type\r\n */ function detectWatermarkProvider(image) {\n    // TODO: Implement provider detection logic\n    // For now, we'll check for both patterns and use the one that matches best\n    // Check if nano banana watermark exists (bottom-right sparkle pattern)\n    // Check if gemini watermark exists (bottom-right \"Gemini\" text pattern)\n    // For now, default to trying both\n    return 'unknown';\n}\n/**\r\n * Detect watermark configuration based on image dimensions and provider\r\n * \r\n * Watermark rules:\r\n * - Gemini: If both width AND height > 1024px â†’ use 96Ã—96, else 48Ã—48\r\n * - Nano Banana: Similar sizing, position in bottom-right corner\r\n * \r\n * Edge cases:\r\n * - Very small images (< 200px) may not have watermarks\r\n * - Watermark position may vary based on aspect ratio\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @param provider - Watermark provider type\r\n * @returns Watermark configuration object\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = detectWatermarkConfig(1920, 1080, 'gemini');\r\n * // Returns: { logoSize: 96, marginRight: 64, marginBottom: 64, provider: 'gemini' }\r\n * ```\r\n */ function detectWatermarkConfig(imageWidth, imageHeight) {\n    let provider = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'unknown';\n    // For very large images, use 96Ã—96 watermark\n    if (imageWidth > 1024 && imageHeight > 1024) {\n        return {\n            logoSize: 96,\n            marginRight: 64,\n            marginBottom: 64,\n            provider\n        };\n    }\n    // For medium/large images with one dimension > 1024\n    if (imageWidth > 1024 || imageHeight > 1024) {\n        return {\n            logoSize: 48,\n            marginRight: 32,\n            marginBottom: 32,\n            provider\n        };\n    }\n    // For smaller images, use smaller watermark with tighter margins\n    return {\n        logoSize: 48,\n        marginRight: 24,\n        marginBottom: 24,\n        provider\n    };\n}\n/**\r\n * Calculate watermark position in image\r\n * \r\n * The watermark is always positioned in the bottom-right corner\r\n * with specific margins based on the watermark size.\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @param config - Watermark configuration\r\n * @returns Watermark position object with x, y, width, height\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = { logoSize: 48, marginRight: 32, marginBottom: 32 };\r\n * const position = calculateWatermarkPosition(1920, 1080, config);\r\n * // Returns: { x: 1840, y: 1000, width: 48, height: 48 }\r\n * ```\r\n */ function calculateWatermarkPosition(imageWidth, imageHeight, config) {\n    const { logoSize, marginRight, marginBottom } = config;\n    return {\n        x: imageWidth - marginRight - logoSize,\n        y: imageHeight - marginBottom - logoSize,\n        width: logoSize,\n        height: logoSize\n    };\n}\n/**\r\n * Watermark Engine Class\r\n * \r\n * Provides high-level API for watermark removal operations.\r\n * Manages alpha maps, background captures, and coordinates the removal process.\r\n * \r\n * @example\r\n * ```typescript\r\n * const engine = await WatermarkEngine.create();\r\n * const result = await engine.removeWatermarkFromImage(imageElement);\r\n * const blob = await new Promise(resolve => result.toBlob(resolve, 'image/png'));\r\n * ```\r\n */ class WatermarkEngine {\n    /**\r\n   * Static factory method to create and initialize engine\r\n   * \r\n   * Loads background capture images asynchronously before\r\n   * creating the engine instance. Supports both Gemini and Nano Banana patterns.\r\n   * \r\n   * @returns Promise resolving to initialized WatermarkEngine\r\n   * @throws Error if images fail to load\r\n   */ static async create() {\n        const bg48 = new Image();\n        const bg96 = new Image();\n        const nanoBanana48 = new Image();\n        const nanoBanana96 = new Image();\n        const loadPromises = [\n            new Promise((resolve, reject)=>{\n                bg48.onload = ()=>resolve();\n                bg48.onerror = (e)=>{\n                    console.error('Failed to load bg_48.png:', e);\n                    reject(new Error(\"Failed to load bg_48.png from \".concat(BG_48_URL)));\n                };\n                bg48.src = BG_48_URL;\n            }),\n            new Promise((resolve, reject)=>{\n                bg96.onload = ()=>resolve();\n                bg96.onerror = (e)=>{\n                    console.error('Failed to load bg_96.png:', e);\n                    reject(new Error(\"Failed to load bg_96.png from \".concat(BG_96_URL)));\n                };\n                bg96.src = BG_96_URL;\n            })\n        ];\n        // Try to load nano banana patterns (optional)\n        const nanoPromises = [\n            new Promise((resolve)=>{\n                nanoBanana48.onload = ()=>{\n                    console.log('âœ… Loaded Nano Banana 48x48 pattern');\n                    resolve();\n                };\n                nanoBanana48.onerror = ()=>{\n                    console.warn('âš ï¸ Nano Banana 48x48 pattern not found, will use Gemini pattern only');\n                    resolve(); // Don't reject, just continue\n                };\n                nanoBanana48.src = NANO_BANANA_48_URL;\n            }),\n            new Promise((resolve)=>{\n                nanoBanana96.onload = ()=>{\n                    console.log('âœ… Loaded Nano Banana 96x96 pattern');\n                    resolve();\n                };\n                nanoBanana96.onerror = ()=>{\n                    console.warn('âš ï¸ Nano Banana 96x96 pattern not found, will use Gemini pattern only');\n                    resolve(); // Don't reject, just continue\n                };\n                nanoBanana96.src = NANO_BANANA_96_URL;\n            })\n        ];\n        await Promise.all([\n            ...loadPromises,\n            ...nanoPromises\n        ]);\n        const captures = {\n            bg48,\n            bg96,\n            nanoBanana48: nanoBanana48.complete && nanoBanana48.naturalWidth > 0 ? nanoBanana48 : undefined,\n            nanoBanana96: nanoBanana96.complete && nanoBanana96.naturalWidth > 0 ? nanoBanana96 : undefined\n        };\n        return new WatermarkEngine(captures);\n    }\n    /**\r\n   * Get or calculate alpha map for watermark size\r\n   * \r\n   * Caches calculated alpha maps for performance.\r\n   * \r\n   * @param size - Watermark size (48 or 96)\r\n   * @returns Promise resolving to Float32Array alpha map\r\n   */ async getAlphaMap(size) {\n        // Return cached alpha map if available\n        if (this.alphaMaps[size]) {\n            return this.alphaMaps[size];\n        }\n        // Select background image based on watermark size\n        const bgImage = size === 48 ? this.bgCaptures.bg48 : this.bgCaptures.bg96;\n        // Extract ImageData from background image\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(bgImage, 0, 0);\n        const imageData = ctx.getImageData(0, 0, size, size);\n        // Calculate and cache alpha map\n        const alphaMap = (0,_alphaMap__WEBPACK_IMPORTED_MODULE_0__.calculateAlphaMap)(imageData);\n        this.alphaMaps[size] = alphaMap;\n        return alphaMap;\n    }\n    /**\r\n   * Remove watermark from image\r\n   * \r\n   * Main entry point for watermark removal. Automatically detects\r\n   * watermark configuration, tries both Gemini and Nano Banana patterns,\r\n   * and applies reverse alpha blending to remove the watermark.\r\n   * \r\n   * @param image - Input image (HTMLImageElement or HTMLCanvasElement)\r\n   * @returns Promise resolving to canvas with watermark removed\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const engine = await WatermarkEngine.create();\r\n   * const processedCanvas = await engine.removeWatermarkFromImage(img);\r\n   * document.body.appendChild(processedCanvas);\r\n   * ```\r\n   */ async removeWatermarkFromImage(image) {\n        // Create canvas for processing\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const ctx = canvas.getContext('2d');\n        // Draw original image\n        ctx.drawImage(image, 0, 0);\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Detect provider (future: smart detection)\n        const provider = detectWatermarkProvider(image);\n        // Detect watermark configuration and position\n        const config = detectWatermarkConfig(canvas.width, canvas.height, provider);\n        const position = calculateWatermarkPosition(canvas.width, canvas.height, config);\n        // Debug logging\n        console.log('ðŸ” Watermark Detection:', {\n            imageSize: \"\".concat(canvas.width, \"\\xd7\").concat(canvas.height),\n            watermarkSize: \"\".concat(config.logoSize, \"\\xd7\").concat(config.logoSize),\n            position: \"(\".concat(position.x, \", \").concat(position.y, \")\"),\n            margins: \"right: \".concat(config.marginRight, \"px, bottom: \").concat(config.marginBottom, \"px\"),\n            provider: config.provider\n        });\n        // Always use Gemini pattern (default behavior)\n        console.log('ðŸ¤– Using Gemini watermark removal...');\n        const alphaMap = await this.getAlphaMap(config.logoSize);\n        (0,_blendModes__WEBPACK_IMPORTED_MODULE_1__.removeWatermark)(imageData, alphaMap, position);\n        ctx.putImageData(imageData, 0, 0);\n        // Debug: Draw detection box (optional - can be enabled for debugging)\n        if ( true && window.__DEBUG_WATERMARK__) {\n            ctx.strokeStyle = '#ff0000';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(position.x, position.y, position.width, position.height);\n            console.log('ðŸŽ¯ Debug box drawn at watermark position');\n        }\n        return canvas;\n    }\n    /**\r\n   * Get watermark information for display purposes\r\n   * \r\n   * Useful for showing watermark details in the UI.\r\n   * \r\n   * @param imageWidth - Image width in pixels\r\n   * @param imageHeight - Image height in pixels\r\n   * @param provider - Optional provider type\r\n   * @returns Watermark information object\r\n   */ getWatermarkInfo(imageWidth, imageHeight) {\n        let provider = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'unknown';\n        const config = detectWatermarkConfig(imageWidth, imageHeight, provider);\n        const position = calculateWatermarkPosition(imageWidth, imageHeight, config);\n        return {\n            size: config.logoSize,\n            position,\n            config,\n            provider: config.provider || 'unknown'\n        };\n    }\n    /**\r\n   * Create new WatermarkEngine instance\r\n   * @param bgCaptures - Background capture images for alpha map calculation\r\n   */ constructor(bgCaptures){\n        this.bgCaptures = bgCaptures;\n        this.alphaMaps = {\n            48: null,\n            96: null\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29yZS93YXRlcm1hcmtFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQVM4QztBQUNBO0FBRS9DLCtCQUErQjtBQUMvQix1RUFBdUU7QUFDdkUsTUFBTUUsWUFBWTtBQUNsQixNQUFNQyxZQUFZO0FBQ2xCLCtDQUErQztBQUMvQyxNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMscUJBQXFCO0FBRTNCOzs7OztDQUtDLEdBQ00sU0FBU0Msd0JBQ2RDLEtBQTJDO0lBRTNDLDJDQUEyQztJQUMzQywyRUFBMkU7SUFFM0UsdUVBQXVFO0lBQ3ZFLHdFQUF3RTtJQUV4RSxrQ0FBa0M7SUFDbEMsT0FBTztBQUNUO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNDLHNCQUNkQyxVQUFrQixFQUNsQkMsV0FBbUI7UUFDbkJDLFdBQUFBLGlFQUE4QjtJQUU5Qiw2Q0FBNkM7SUFDN0MsSUFBSUYsYUFBYSxRQUFRQyxjQUFjLE1BQU07UUFDM0MsT0FBTztZQUNMRSxVQUFVO1lBQ1ZDLGFBQWE7WUFDYkMsY0FBYztZQUNkSDtRQUNGO0lBQ0Y7SUFFQSxvREFBb0Q7SUFDcEQsSUFBSUYsYUFBYSxRQUFRQyxjQUFjLE1BQU07UUFDM0MsT0FBTztZQUNMRSxVQUFVO1lBQ1ZDLGFBQWE7WUFDYkMsY0FBYztZQUNkSDtRQUNGO0lBQ0Y7SUFFQSxpRUFBaUU7SUFDakUsT0FBTztRQUNMQyxVQUFVO1FBQ1ZDLGFBQWE7UUFDYkMsY0FBYztRQUNkSDtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTSSwyQkFDZE4sVUFBa0IsRUFDbEJDLFdBQW1CLEVBQ25CTSxNQUF1QjtJQUV2QixNQUFNLEVBQUVKLFFBQVEsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBR0U7SUFFaEQsT0FBTztRQUNMQyxHQUFHUixhQUFhSSxjQUFjRDtRQUM5Qk0sR0FB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QztZQUN4RUgsVUFBVUssT0FBT0wsUUFBUTtRQUMzQjtRQUVBLCtDQUErQztRQUMvQ3dCLFFBQVFLLEdBQUcsQ0FBQztRQUNaLE1BQU1vQixXQUFXLE1BQU0sSUFBSSxDQUFDYixXQUFXLENBQUMvQixPQUFPSixRQUFRO1FBQ3ZEWCw0REFBZUEsQ0FBQ3lELFdBQVdFLFVBQVVFO1FBQ3JDUCxJQUFJVyxZQUFZLENBQUNSLFdBQVcsR0FBRztRQUUvQixzRUFBc0U7UUFDdEUsSUFBSSxLQUE2QixJQUFJLE9BQWdCVSxtQkFBbUIsRUFBRTtZQUN4RWIsSUFBSWMsV0FBVyxHQUFHO1lBQ2xCZCxJQUFJZSxTQUFTLEdBQUc7WUFDaEJmLElBQUlnQixVQUFVLENBQUNULFNBQVM3QyxDQUFDLEVBQUU2QyxTQUFTNUMsQ0FBQyxFQUFFNEMsU0FBUzNDLEtBQUssRUFBRTJDLFNBQVMxQyxNQUFNO1lBQ3RFZSxRQUFRSyxHQUFHLENBQUM7UUFDZDtRQUVBLE9BQU9ZO0lBQ1Q7SUFFQTs7Ozs7Ozs7O0dBU0MsR0FDRG9CLGlCQUFpQi9ELFVBQWtCLEVBQUVDLFdBQW1CLEVBQTBEO1lBQXhEQyxXQUFBQSxpRUFBOEI7UUFDdEYsTUFBTUssU0FBU1Isc0JBQXNCQyxZQUFZQyxhQUFhQztRQUM5RCxNQUFNbUQsV0FBVy9DLDJCQUEyQk4sWUFBWUMsYUFBYU07UUFFckUsT0FBTztZQUNMZ0MsTUFBTWhDLE9BQU9KLFFBQVE7WUFDckJrRDtZQUNBOUM7WUFDQUwsVUFBVUssT0FBT0wsUUFBUSxJQUFJO1FBQy9CO0lBQ0Y7SUExTUE7OztHQUdDLEdBQ0QsWUFBWXdDLFVBQThCLENBQUU7UUFDMUMsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0YsU0FBUyxHQUFHO1lBQ2YsSUFBSTtZQUNKLElBQUk7UUFDTjtJQUNGO0FBaU1GIiwic291cmNlcyI6WyJDOlxcZGV2XFxnZW1pbmktd2F0ZXJtYXJrLXJlbW92ZXItbWFpblxcc3JjXFxsaWJcXGNvcmVcXHdhdGVybWFya0VuZ2luZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogV2F0ZXJtYXJrIEVuZ2luZSAtIE1haW4gTW9kdWxlXHJcbiAqIEBmaWxlb3ZlcnZpZXcgQ29vcmRpbmF0ZXMgd2F0ZXJtYXJrIGRldGVjdGlvbiwgYWxwaGEgbWFwIGNhbGN1bGF0aW9uLCBhbmQgcmVtb3ZhbCBvcGVyYXRpb25zXHJcbiAqIEBtb2R1bGUgd2F0ZXJtYXJrRW5naW5lXHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge1xyXG4gIFdhdGVybWFya0NvbmZpZyxcclxuICBXYXRlcm1hcmtQb3NpdGlvbixcclxuICBXYXRlcm1hcmtJbmZvLFxyXG4gIEJhY2tncm91bmRDYXB0dXJlcyxcclxuICBXYXRlcm1hcmtQcm92aWRlcixcclxufSBmcm9tICdAL3R5cGVzJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlQWxwaGFNYXAgfSBmcm9tICcuL2FscGhhTWFwJztcclxuaW1wb3J0IHsgcmVtb3ZlV2F0ZXJtYXJrIH0gZnJvbSAnLi9ibGVuZE1vZGVzJztcclxuXHJcbi8vIEltcG9ydCBhc3NldHMgYXMgc3RhdGljIFVSTHNcclxuLy8gTm90ZTogSW4gTmV4dC5qcywgd2UnbGwgdXNlIGR5bmFtaWMgaW1wb3J0cyBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHlcclxuY29uc3QgQkdfNDhfVVJMID0gJy9iZ180OC5wbmcnO1xyXG5jb25zdCBCR185Nl9VUkwgPSAnL2JnXzk2LnBuZyc7XHJcbi8vIE5hbm8gQmFuYW5hIHdhdGVybWFyayBwYXR0ZXJucyAodG8gYmUgYWRkZWQpXHJcbmNvbnN0IE5BTk9fQkFOQU5BXzQ4X1VSTCA9ICcvbmFub19iYW5hbmFfNDgucG5nJztcclxuY29uc3QgTkFOT19CQU5BTkFfOTZfVVJMID0gJy9uYW5vX2JhbmFuYV85Ni5wbmcnO1xyXG5cclxuLyoqXHJcbiAqIERldGVjdCB3YXRlcm1hcmsgcHJvdmlkZXIgZnJvbSBpbWFnZSBtZXRhZGF0YSBvciBwYXR0ZXJuc1xyXG4gKiBcclxuICogQHBhcmFtIGltYWdlIC0gSW1hZ2UgZWxlbWVudCB0byBhbmFseXplXHJcbiAqIEByZXR1cm5zIERldGVjdGVkIHByb3ZpZGVyIHR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RXYXRlcm1hcmtQcm92aWRlcihcclxuICBpbWFnZTogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50XHJcbik6IFdhdGVybWFya1Byb3ZpZGVyIHtcclxuICAvLyBUT0RPOiBJbXBsZW1lbnQgcHJvdmlkZXIgZGV0ZWN0aW9uIGxvZ2ljXHJcbiAgLy8gRm9yIG5vdywgd2UnbGwgY2hlY2sgZm9yIGJvdGggcGF0dGVybnMgYW5kIHVzZSB0aGUgb25lIHRoYXQgbWF0Y2hlcyBiZXN0XHJcbiAgXHJcbiAgLy8gQ2hlY2sgaWYgbmFubyBiYW5hbmEgd2F0ZXJtYXJrIGV4aXN0cyAoYm90dG9tLXJpZ2h0IHNwYXJrbGUgcGF0dGVybilcclxuICAvLyBDaGVjayBpZiBnZW1pbmkgd2F0ZXJtYXJrIGV4aXN0cyAoYm90dG9tLXJpZ2h0IFwiR2VtaW5pXCIgdGV4dCBwYXR0ZXJuKVxyXG4gIFxyXG4gIC8vIEZvciBub3csIGRlZmF1bHQgdG8gdHJ5aW5nIGJvdGhcclxuICByZXR1cm4gJ3Vua25vd24nO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IHdhdGVybWFyayBjb25maWd1cmF0aW9uIGJhc2VkIG9uIGltYWdlIGRpbWVuc2lvbnMgYW5kIHByb3ZpZGVyXHJcbiAqIFxyXG4gKiBXYXRlcm1hcmsgcnVsZXM6XHJcbiAqIC0gR2VtaW5pOiBJZiBib3RoIHdpZHRoIEFORCBoZWlnaHQgPiAxMDI0cHgg4oaSIHVzZSA5NsOXOTYsIGVsc2UgNDjDlzQ4XHJcbiAqIC0gTmFubyBCYW5hbmE6IFNpbWlsYXIgc2l6aW5nLCBwb3NpdGlvbiBpbiBib3R0b20tcmlnaHQgY29ybmVyXHJcbiAqIFxyXG4gKiBFZGdlIGNhc2VzOlxyXG4gKiAtIFZlcnkgc21hbGwgaW1hZ2VzICg8IDIwMHB4KSBtYXkgbm90IGhhdmUgd2F0ZXJtYXJrc1xyXG4gKiAtIFdhdGVybWFyayBwb3NpdGlvbiBtYXkgdmFyeSBiYXNlZCBvbiBhc3BlY3QgcmF0aW9cclxuICogXHJcbiAqIEBwYXJhbSBpbWFnZVdpZHRoIC0gSW1hZ2Ugd2lkdGggaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSBpbWFnZUhlaWdodCAtIEltYWdlIGhlaWdodCBpbiBwaXhlbHNcclxuICogQHBhcmFtIHByb3ZpZGVyIC0gV2F0ZXJtYXJrIHByb3ZpZGVyIHR5cGVcclxuICogQHJldHVybnMgV2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGNvbmZpZyA9IGRldGVjdFdhdGVybWFya0NvbmZpZygxOTIwLCAxMDgwLCAnZ2VtaW5pJyk7XHJcbiAqIC8vIFJldHVybnM6IHsgbG9nb1NpemU6IDk2LCBtYXJnaW5SaWdodDogNjQsIG1hcmdpbkJvdHRvbTogNjQsIHByb3ZpZGVyOiAnZ2VtaW5pJyB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFdhdGVybWFya0NvbmZpZyhcclxuICBpbWFnZVdpZHRoOiBudW1iZXIsXHJcbiAgaW1hZ2VIZWlnaHQ6IG51bWJlcixcclxuICBwcm92aWRlcjogV2F0ZXJtYXJrUHJvdmlkZXIgPSAndW5rbm93bidcclxuKTogV2F0ZXJtYXJrQ29uZmlnIHtcclxuICAvLyBGb3IgdmVyeSBsYXJnZSBpbWFnZXMsIHVzZSA5NsOXOTYgd2F0ZXJtYXJrXHJcbiAgaWYgKGltYWdlV2lkdGggPiAxMDI0ICYmIGltYWdlSGVpZ2h0ID4gMTAyNCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9nb1NpemU6IDk2LFxyXG4gICAgICBtYXJnaW5SaWdodDogNjQsXHJcbiAgICAgIG1hcmdpbkJvdHRvbTogNjQsXHJcbiAgICAgIHByb3ZpZGVyLFxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLy8gRm9yIG1lZGl1bS9sYXJnZSBpbWFnZXMgd2l0aCBvbmUgZGltZW5zaW9uID4gMTAyNFxyXG4gIGlmIChpbWFnZVdpZHRoID4gMTAyNCB8fCBpbWFnZUhlaWdodCA+IDEwMjQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxvZ29TaXplOiA0OCxcclxuICAgICAgbWFyZ2luUmlnaHQ6IDMyLFxyXG4gICAgICBtYXJnaW5Cb3R0b206IDMyLFxyXG4gICAgICBwcm92aWRlcixcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZvciBzbWFsbGVyIGltYWdlcywgdXNlIHNtYWxsZXIgd2F0ZXJtYXJrIHdpdGggdGlnaHRlciBtYXJnaW5zXHJcbiAgcmV0dXJuIHtcclxuICAgIGxvZ29TaXplOiA0OCxcclxuICAgIG1hcmdpblJpZ2h0OiAyNCxcclxuICAgIG1hcmdpbkJvdHRvbTogMjQsXHJcbiAgICBwcm92aWRlcixcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHdhdGVybWFyayBwb3NpdGlvbiBpbiBpbWFnZVxyXG4gKiBcclxuICogVGhlIHdhdGVybWFyayBpcyBhbHdheXMgcG9zaXRpb25lZCBpbiB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lclxyXG4gKiB3aXRoIHNwZWNpZmljIG1hcmdpbnMgYmFzZWQgb24gdGhlIHdhdGVybWFyayBzaXplLlxyXG4gKiBcclxuICogQHBhcmFtIGltYWdlV2lkdGggLSBJbWFnZSB3aWR0aCBpbiBwaXhlbHNcclxuICogQHBhcmFtIGltYWdlSGVpZ2h0IC0gSW1hZ2UgaGVpZ2h0IGluIHBpeGVsc1xyXG4gKiBAcGFyYW0gY29uZmlnIC0gV2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb25cclxuICogQHJldHVybnMgV2F0ZXJtYXJrIHBvc2l0aW9uIG9iamVjdCB3aXRoIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgY29uZmlnID0geyBsb2dvU2l6ZTogNDgsIG1hcmdpblJpZ2h0OiAzMiwgbWFyZ2luQm90dG9tOiAzMiB9O1xyXG4gKiBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKDE5MjAsIDEwODAsIGNvbmZpZyk7XHJcbiAqIC8vIFJldHVybnM6IHsgeDogMTg0MCwgeTogMTAwMCwgd2lkdGg6IDQ4LCBoZWlnaHQ6IDQ4IH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV2F0ZXJtYXJrUG9zaXRpb24oXHJcbiAgaW1hZ2VXaWR0aDogbnVtYmVyLFxyXG4gIGltYWdlSGVpZ2h0OiBudW1iZXIsXHJcbiAgY29uZmlnOiBXYXRlcm1hcmtDb25maWdcclxuKTogV2F0ZXJtYXJrUG9zaXRpb24ge1xyXG4gIGNvbnN0IHsgbG9nb1NpemUsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20gfSA9IGNvbmZpZztcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IGltYWdlV2lkdGggLSBtYXJnaW5SaWdodCAtIGxvZ29TaXplLFxyXG4gICAgeTogaW1hZ2VIZWlnaHQgLSBtYXJnaW5Cb3R0b20gLSBsb2dvU2l6ZSxcclxuICAgIHdpZHRoOiBsb2dvU2l6ZSxcclxuICAgIGhlaWdodDogbG9nb1NpemUsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdhdGVybWFyayBFbmdpbmUgQ2xhc3NcclxuICogXHJcbiAqIFByb3ZpZGVzIGhpZ2gtbGV2ZWwgQVBJIGZvciB3YXRlcm1hcmsgcmVtb3ZhbCBvcGVyYXRpb25zLlxyXG4gKiBNYW5hZ2VzIGFscGhhIG1hcHMsIGJhY2tncm91bmQgY2FwdHVyZXMsIGFuZCBjb29yZGluYXRlcyB0aGUgcmVtb3ZhbCBwcm9jZXNzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBlbmdpbmUgPSBhd2FpdCBXYXRlcm1hcmtFbmdpbmUuY3JlYXRlKCk7XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVuZ2luZS5yZW1vdmVXYXRlcm1hcmtGcm9tSW1hZ2UoaW1hZ2VFbGVtZW50KTtcclxuICogY29uc3QgYmxvYiA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcmVzdWx0LnRvQmxvYihyZXNvbHZlLCAnaW1hZ2UvcG5nJykpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBXYXRlcm1hcmtFbmdpbmUge1xyXG4gIHByaXZhdGUgYmdDYXB0dXJlczogQmFja2dyb3VuZENhcHR1cmVzO1xyXG4gIHByaXZhdGUgYWxwaGFNYXBzOiBSZWNvcmQ8NDggfCA5NiwgRmxvYXQzMkFycmF5IHwgbnVsbD47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgV2F0ZXJtYXJrRW5naW5lIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIGJnQ2FwdHVyZXMgLSBCYWNrZ3JvdW5kIGNhcHR1cmUgaW1hZ2VzIGZvciBhbHBoYSBtYXAgY2FsY3VsYXRpb25cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihiZ0NhcHR1cmVzOiBCYWNrZ3JvdW5kQ2FwdHVyZXMpIHtcclxuICAgIHRoaXMuYmdDYXB0dXJlcyA9IGJnQ2FwdHVyZXM7XHJcbiAgICB0aGlzLmFscGhhTWFwcyA9IHtcclxuICAgICAgNDg6IG51bGwsXHJcbiAgICAgIDk2OiBudWxsLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXRpYyBmYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgZW5naW5lXHJcbiAgICogXHJcbiAgICogTG9hZHMgYmFja2dyb3VuZCBjYXB0dXJlIGltYWdlcyBhc3luY2hyb25vdXNseSBiZWZvcmVcclxuICAgKiBjcmVhdGluZyB0aGUgZW5naW5lIGluc3RhbmNlLiBTdXBwb3J0cyBib3RoIEdlbWluaSBhbmQgTmFubyBCYW5hbmEgcGF0dGVybnMuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW5pdGlhbGl6ZWQgV2F0ZXJtYXJrRW5naW5lXHJcbiAgICogQHRocm93cyBFcnJvciBpZiBpbWFnZXMgZmFpbCB0byBsb2FkXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSgpOiBQcm9taXNlPFdhdGVybWFya0VuZ2luZT4ge1xyXG4gICAgY29uc3QgYmc0OCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29uc3QgYmc5NiA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29uc3QgbmFub0JhbmFuYTQ4ID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb25zdCBuYW5vQmFuYW5hOTYgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBbXHJcbiAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBiZzQ4Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICBiZzQ4Lm9uZXJyb3IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgYmdfNDgucG5nOicsIGUpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgYmdfNDgucG5nIGZyb20gJHtCR180OF9VUkx9YCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYmc0OC5zcmMgPSBCR180OF9VUkw7XHJcbiAgICAgIH0pLFxyXG4gICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgYmc5Ni5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgYmc5Ni5vbmVycm9yID0gKGUpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGJnXzk2LnBuZzonLCBlKTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGJnXzk2LnBuZyBmcm9tICR7QkdfOTZfVVJMfWApKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJnOTYuc3JjID0gQkdfOTZfVVJMO1xyXG4gICAgICB9KSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gVHJ5IHRvIGxvYWQgbmFubyBiYW5hbmEgcGF0dGVybnMgKG9wdGlvbmFsKVxyXG4gICAgY29uc3QgbmFub1Byb21pc2VzID0gW1xyXG4gICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIG5hbm9CYW5hbmE0OC5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIExvYWRlZCBOYW5vIEJhbmFuYSA0OHg0OCBwYXR0ZXJuJyk7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW5vQmFuYW5hNDgub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5hbm8gQmFuYW5hIDQ4eDQ4IHBhdHRlcm4gbm90IGZvdW5kLCB3aWxsIHVzZSBHZW1pbmkgcGF0dGVybiBvbmx5Jyk7XHJcbiAgICAgICAgICByZXNvbHZlKCk7IC8vIERvbid0IHJlamVjdCwganVzdCBjb250aW51ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFub0JhbmFuYTQ4LnNyYyA9IE5BTk9fQkFOQU5BXzQ4X1VSTDtcclxuICAgICAgfSksXHJcbiAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgbmFub0JhbmFuYTk2Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgTG9hZGVkIE5hbm8gQmFuYW5hIDk2eDk2IHBhdHRlcm4nKTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG5hbm9CYW5hbmE5Ni5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTmFubyBCYW5hbmEgOTZ4OTYgcGF0dGVybiBub3QgZm91bmQsIHdpbGwgdXNlIEdlbWluaSBwYXR0ZXJuIG9ubHknKTtcclxuICAgICAgICAgIHJlc29sdmUoKTsgLy8gRG9uJ3QgcmVqZWN0LCBqdXN0IGNvbnRpbnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW5vQmFuYW5hOTYuc3JjID0gTkFOT19CQU5BTkFfOTZfVVJMO1xyXG4gICAgICB9KSxcclxuICAgIF07XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLmxvYWRQcm9taXNlcywgLi4ubmFub1Byb21pc2VzXSk7XHJcblxyXG4gICAgY29uc3QgY2FwdHVyZXM6IEJhY2tncm91bmRDYXB0dXJlcyA9IHtcclxuICAgICAgYmc0OCxcclxuICAgICAgYmc5NixcclxuICAgICAgbmFub0JhbmFuYTQ4OiBuYW5vQmFuYW5hNDguY29tcGxldGUgJiYgbmFub0JhbmFuYTQ4Lm5hdHVyYWxXaWR0aCA+IDAgPyBuYW5vQmFuYW5hNDggOiB1bmRlZmluZWQsXHJcbiAgICAgIG5hbm9CYW5hbmE5NjogbmFub0JhbmFuYTk2LmNvbXBsZXRlICYmIG5hbm9CYW5hbmE5Ni5uYXR1cmFsV2lkdGggPiAwID8gbmFub0JhbmFuYTk2IDogdW5kZWZpbmVkLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFdhdGVybWFya0VuZ2luZShjYXB0dXJlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3IgY2FsY3VsYXRlIGFscGhhIG1hcCBmb3Igd2F0ZXJtYXJrIHNpemVcclxuICAgKiBcclxuICAgKiBDYWNoZXMgY2FsY3VsYXRlZCBhbHBoYSBtYXBzIGZvciBwZXJmb3JtYW5jZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gc2l6ZSAtIFdhdGVybWFyayBzaXplICg0OCBvciA5NilcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBGbG9hdDMyQXJyYXkgYWxwaGEgbWFwXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0QWxwaGFNYXAoc2l6ZTogNDggfCA5Nik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XHJcbiAgICAvLyBSZXR1cm4gY2FjaGVkIGFscGhhIG1hcCBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0aGlzLmFscGhhTWFwc1tzaXplXSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hbHBoYU1hcHNbc2l6ZV0hO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbGVjdCBiYWNrZ3JvdW5kIGltYWdlIGJhc2VkIG9uIHdhdGVybWFyayBzaXplXHJcbiAgICBjb25zdCBiZ0ltYWdlID0gc2l6ZSA9PT0gNDggPyB0aGlzLmJnQ2FwdHVyZXMuYmc0OCA6IHRoaXMuYmdDYXB0dXJlcy5iZzk2O1xyXG5cclxuICAgIC8vIEV4dHJhY3QgSW1hZ2VEYXRhIGZyb20gYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSBzaXplO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHNpemU7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcbiAgICBjdHguZHJhd0ltYWdlKGJnSW1hZ2UsIDAsIDApO1xyXG5cclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGFuZCBjYWNoZSBhbHBoYSBtYXBcclxuICAgIGNvbnN0IGFscGhhTWFwID0gY2FsY3VsYXRlQWxwaGFNYXAoaW1hZ2VEYXRhKTtcclxuICAgIHRoaXMuYWxwaGFNYXBzW3NpemVdID0gYWxwaGFNYXA7XHJcblxyXG4gICAgcmV0dXJuIGFscGhhTWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHdhdGVybWFyayBmcm9tIGltYWdlXHJcbiAgICogXHJcbiAgICogTWFpbiBlbnRyeSBwb2ludCBmb3Igd2F0ZXJtYXJrIHJlbW92YWwuIEF1dG9tYXRpY2FsbHkgZGV0ZWN0c1xyXG4gICAqIHdhdGVybWFyayBjb25maWd1cmF0aW9uLCB0cmllcyBib3RoIEdlbWluaSBhbmQgTmFubyBCYW5hbmEgcGF0dGVybnMsXHJcbiAgICogYW5kIGFwcGxpZXMgcmV2ZXJzZSBhbHBoYSBibGVuZGluZyB0byByZW1vdmUgdGhlIHdhdGVybWFyay5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gaW1hZ2UgLSBJbnB1dCBpbWFnZSAoSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudClcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBjYW52YXMgd2l0aCB3YXRlcm1hcmsgcmVtb3ZlZFxyXG4gICAqIFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IGVuZ2luZSA9IGF3YWl0IFdhdGVybWFya0VuZ2luZS5jcmVhdGUoKTtcclxuICAgKiBjb25zdCBwcm9jZXNzZWRDYW52YXMgPSBhd2FpdCBlbmdpbmUucmVtb3ZlV2F0ZXJtYXJrRnJvbUltYWdlKGltZyk7XHJcbiAgICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcm9jZXNzZWRDYW52YXMpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZVdhdGVybWFya0Zyb21JbWFnZShcclxuICAgIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnRcclxuICApOiBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PiB7XHJcbiAgICAvLyBDcmVhdGUgY2FudmFzIGZvciBwcm9jZXNzaW5nXHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICAvLyBEcmF3IG9yaWdpbmFsIGltYWdlXHJcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcclxuXHJcbiAgICAvLyBHZXQgaW1hZ2UgZGF0YVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgIC8vIERldGVjdCBwcm92aWRlciAoZnV0dXJlOiBzbWFydCBkZXRlY3Rpb24pXHJcbiAgICBjb25zdCBwcm92aWRlciA9IGRldGVjdFdhdGVybWFya1Byb3ZpZGVyKGltYWdlKTtcclxuXHJcbiAgICAvLyBEZXRlY3Qgd2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb24gYW5kIHBvc2l0aW9uXHJcbiAgICBjb25zdCBjb25maWcgPSBkZXRlY3RXYXRlcm1hcmtDb25maWcoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCBwcm92aWRlcik7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgY29uZmlnKTtcclxuXHJcbiAgICAvLyBEZWJ1ZyBsb2dnaW5nXHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBXYXRlcm1hcmsgRGV0ZWN0aW9uOicsIHtcclxuICAgICAgaW1hZ2VTaXplOiBgJHtjYW52YXMud2lkdGh9w5cke2NhbnZhcy5oZWlnaHR9YCxcclxuICAgICAgd2F0ZXJtYXJrU2l6ZTogYCR7Y29uZmlnLmxvZ29TaXplfcOXJHtjb25maWcubG9nb1NpemV9YCxcclxuICAgICAgcG9zaXRpb246IGAoJHtwb3NpdGlvbi54fSwgJHtwb3NpdGlvbi55fSlgLFxyXG4gICAgICBtYXJnaW5zOiBgcmlnaHQ6ICR7Y29uZmlnLm1hcmdpblJpZ2h0fXB4LCBib3R0b206ICR7Y29uZmlnLm1hcmdpbkJvdHRvbX1weGAsXHJcbiAgICAgIHByb3ZpZGVyOiBjb25maWcucHJvdmlkZXIsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBbHdheXMgdXNlIEdlbWluaSBwYXR0ZXJuIChkZWZhdWx0IGJlaGF2aW9yKVxyXG4gICAgY29uc29sZS5sb2coJ/CfpJYgVXNpbmcgR2VtaW5pIHdhdGVybWFyayByZW1vdmFsLi4uJyk7XHJcbiAgICBjb25zdCBhbHBoYU1hcCA9IGF3YWl0IHRoaXMuZ2V0QWxwaGFNYXAoY29uZmlnLmxvZ29TaXplKTtcclxuICAgIHJlbW92ZVdhdGVybWFyayhpbWFnZURhdGEsIGFscGhhTWFwLCBwb3NpdGlvbik7XHJcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgLy8gRGVidWc6IERyYXcgZGV0ZWN0aW9uIGJveCAob3B0aW9uYWwgLSBjYW4gYmUgZW5hYmxlZCBmb3IgZGVidWdnaW5nKVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5fX0RFQlVHX1dBVEVSTUFSS19fKSB7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmYwMDAwJztcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgIGN0eC5zdHJva2VSZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLndpZHRoLCBwb3NpdGlvbi5oZWlnaHQpO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBEZWJ1ZyBib3ggZHJhd24gYXQgd2F0ZXJtYXJrIHBvc2l0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB3YXRlcm1hcmsgaW5mb3JtYXRpb24gZm9yIGRpc3BsYXkgcHVycG9zZXNcclxuICAgKiBcclxuICAgKiBVc2VmdWwgZm9yIHNob3dpbmcgd2F0ZXJtYXJrIGRldGFpbHMgaW4gdGhlIFVJLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBpbWFnZVdpZHRoIC0gSW1hZ2Ugd2lkdGggaW4gcGl4ZWxzXHJcbiAgICogQHBhcmFtIGltYWdlSGVpZ2h0IC0gSW1hZ2UgaGVpZ2h0IGluIHBpeGVsc1xyXG4gICAqIEBwYXJhbSBwcm92aWRlciAtIE9wdGlvbmFsIHByb3ZpZGVyIHR5cGVcclxuICAgKiBAcmV0dXJucyBXYXRlcm1hcmsgaW5mb3JtYXRpb24gb2JqZWN0XHJcbiAgICovXHJcbiAgZ2V0V2F0ZXJtYXJrSW5mbyhpbWFnZVdpZHRoOiBudW1iZXIsIGltYWdlSGVpZ2h0OiBudW1iZXIsIHByb3ZpZGVyOiBXYXRlcm1hcmtQcm92aWRlciA9ICd1bmtub3duJyk6IFdhdGVybWFya0luZm8ge1xyXG4gICAgY29uc3QgY29uZmlnID0gZGV0ZWN0V2F0ZXJtYXJrQ29uZmlnKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBwcm92aWRlcik7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNpemU6IGNvbmZpZy5sb2dvU2l6ZSxcclxuICAgICAgcG9zaXRpb24sXHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgcHJvdmlkZXI6IGNvbmZpZy5wcm92aWRlciB8fCAndW5rbm93bicsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlQWxwaGFNYXAiLCJyZW1vdmVXYXRlcm1hcmsiLCJCR180OF9VUkwiLCJCR185Nl9VUkwiLCJOQU5PX0JBTkFOQV80OF9VUkwiLCJOQU5PX0JBTkFOQV85Nl9VUkwiLCJkZXRlY3RXYXRlcm1hcmtQcm92aWRlciIsImltYWdlIiwiZGV0ZWN0V2F0ZXJtYXJrQ29uZmlnIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwicHJvdmlkZXIiLCJsb2dvU2l6ZSIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwiY2FsY3VsYXRlV2F0ZXJtYXJrUG9zaXRpb24iLCJjb25maWciLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiV2F0ZXJtYXJrRW5naW5lIiwiY3JlYXRlIiwiYmc0OCIsIkltYWdlIiwiYmc5NiIsIm5hbm9CYW5hbmE0OCIsIm5hbm9CYW5hbmE5NiIsImxvYWRQcm9taXNlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwib25lcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsInNyYyIsIm5hbm9Qcm9taXNlcyIsImxvZyIsIndhcm4iLCJhbGwiLCJjYXB0dXJlcyIsImNvbXBsZXRlIiwibmF0dXJhbFdpZHRoIiwidW5kZWZpbmVkIiwiZ2V0QWxwaGFNYXAiLCJzaXplIiwiYWxwaGFNYXBzIiwiYmdJbWFnZSIsImJnQ2FwdHVyZXMiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiYWxwaGFNYXAiLCJyZW1vdmVXYXRlcm1hcmtGcm9tSW1hZ2UiLCJwb3NpdGlvbiIsImltYWdlU2l6ZSIsIndhdGVybWFya1NpemUiLCJtYXJnaW5zIiwicHV0SW1hZ2VEYXRhIiwid2luZG93IiwiX19ERUJVR19XQVRFUk1BUktfXyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlUmVjdCIsImdldFdhdGVybWFya0luZm8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/core/watermarkEngine.ts\n"));

/***/ })

});