"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_WatermarkRemover_tsx",{

/***/ "(app-pages-browser)/./src/lib/core/watermarkEngine.ts":
/*!*****************************************!*\
  !*** ./src/lib/core/watermarkEngine.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WatermarkEngine: () => (/* binding */ WatermarkEngine),\n/* harmony export */   calculateWatermarkPosition: () => (/* binding */ calculateWatermarkPosition),\n/* harmony export */   detectWatermarkConfig: () => (/* binding */ detectWatermarkConfig)\n/* harmony export */ });\n/* harmony import */ var _alphaMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alphaMap */ \"(app-pages-browser)/./src/lib/core/alphaMap.ts\");\n/* harmony import */ var _blendModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blendModes */ \"(app-pages-browser)/./src/lib/core/blendModes.ts\");\n/**\r\n * Watermark Engine - Main Module\r\n * @fileoverview Coordinates watermark detection, alpha map calculation, and removal operations\r\n * @module watermarkEngine\r\n */ \n\n// Import assets as static URLs\n// Note: In Next.js, we'll use dynamic imports for better compatibility\nconst BG_48_URL = '/bg_48.png';\nconst BG_96_URL = '/bg_96.png';\n/**\r\n * Detect watermark configuration based on image dimensions\r\n * \r\n * Gemini's watermark rules:\r\n * - If both width AND height > 1024px ‚Üí use 96√ó96 watermark\r\n * - Otherwise ‚Üí use 48√ó48 watermark\r\n * \r\n * Edge cases:\r\n * - Very small images (< 200px) may not have watermarks\r\n * - Watermark position may vary based on aspect ratio\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @returns Watermark configuration object\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = detectWatermarkConfig(1920, 1080);\r\n * // Returns: { logoSize: 96, marginRight: 64, marginBottom: 64 }\r\n * ```\r\n */ function detectWatermarkConfig(imageWidth, imageHeight) {\n    // For very large images, use 96√ó96 watermark\n    if (imageWidth > 1024 && imageHeight > 1024) {\n        return {\n            logoSize: 96,\n            marginRight: 64,\n            marginBottom: 64\n        };\n    }\n    // For medium/large images with one dimension > 1024\n    if (imageWidth > 1024 || imageHeight > 1024) {\n        return {\n            logoSize: 48,\n            marginRight: 32,\n            marginBottom: 32\n        };\n    }\n    // For smaller images, use smaller watermark with tighter margins\n    return {\n        logoSize: 48,\n        marginRight: 24,\n        marginBottom: 24\n    };\n}\n/**\r\n * Calculate watermark position in image\r\n * \r\n * The watermark is always positioned in the bottom-right corner\r\n * with specific margins based on the watermark size.\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @param config - Watermark configuration\r\n * @returns Watermark position object with x, y, width, height\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = { logoSize: 48, marginRight: 32, marginBottom: 32 };\r\n * const position = calculateWatermarkPosition(1920, 1080, config);\r\n * // Returns: { x: 1840, y: 1000, width: 48, height: 48 }\r\n * ```\r\n */ function calculateWatermarkPosition(imageWidth, imageHeight, config) {\n    const { logoSize, marginRight, marginBottom } = config;\n    return {\n        x: imageWidth - marginRight - logoSize,\n        y: imageHeight - marginBottom - logoSize,\n        width: logoSize,\n        height: logoSize\n    };\n}\n/**\r\n * Watermark Engine Class\r\n * \r\n * Provides high-level API for watermark removal operations.\r\n * Manages alpha maps, background captures, and coordinates the removal process.\r\n * \r\n * @example\r\n * ```typescript\r\n * const engine = await WatermarkEngine.create();\r\n * const result = await engine.removeWatermarkFromImage(imageElement);\r\n * const blob = await new Promise(resolve => result.toBlob(resolve, 'image/png'));\r\n * ```\r\n */ class WatermarkEngine {\n    /**\r\n   * Static factory method to create and initialize engine\r\n   * \r\n   * Loads background capture images asynchronously before\r\n   * creating the engine instance.\r\n   * \r\n   * @returns Promise resolving to initialized WatermarkEngine\r\n   * @throws Error if images fail to load\r\n   */ static async create() {\n        const bg48 = new Image();\n        const bg96 = new Image();\n        await Promise.all([\n            new Promise((resolve, reject)=>{\n                bg48.onload = ()=>resolve();\n                bg48.onerror = (e)=>{\n                    console.error('Failed to load bg_48.png:', e);\n                    reject(new Error(\"Failed to load bg_48.png from \".concat(BG_48_URL)));\n                };\n                bg48.src = BG_48_URL;\n            }),\n            new Promise((resolve, reject)=>{\n                bg96.onload = ()=>resolve();\n                bg96.onerror = (e)=>{\n                    console.error('Failed to load bg_96.png:', e);\n                    reject(new Error(\"Failed to load bg_96.png from \".concat(BG_96_URL)));\n                };\n                bg96.src = BG_96_URL;\n            })\n        ]);\n        return new WatermarkEngine({\n            bg48,\n            bg96\n        });\n    }\n    /**\r\n   * Get or calculate alpha map for watermark size\r\n   * \r\n   * Caches calculated alpha maps for performance.\r\n   * \r\n   * @param size - Watermark size (48 or 96)\r\n   * @returns Promise resolving to Float32Array alpha map\r\n   */ async getAlphaMap(size) {\n        // Return cached alpha map if available\n        if (this.alphaMaps[size]) {\n            return this.alphaMaps[size];\n        }\n        // Select background image based on watermark size\n        const bgImage = size === 48 ? this.bgCaptures.bg48 : this.bgCaptures.bg96;\n        // Extract ImageData from background image\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(bgImage, 0, 0);\n        const imageData = ctx.getImageData(0, 0, size, size);\n        // Calculate and cache alpha map\n        const alphaMap = (0,_alphaMap__WEBPACK_IMPORTED_MODULE_0__.calculateAlphaMap)(imageData);\n        this.alphaMaps[size] = alphaMap;\n        return alphaMap;\n    }\n    /**\r\n   * Remove watermark from image\r\n   * \r\n   * Main entry point for watermark removal. Automatically detects\r\n   * watermark configuration, calculates position, and applies\r\n   * reverse alpha blending to remove the watermark.\r\n   * \r\n   * @param image - Input image (HTMLImageElement or HTMLCanvasElement)\r\n   * @returns Promise resolving to canvas with watermark removed\r\n   * \r\n   * @example\r\n   * ```typescript\r\n * const engine = await WatermarkEngine.create();\r\n   * const processedCanvas = await engine.removeWatermarkFromImage(img);\r\n   * document.body.appendChild(processedCanvas);\r\n   * ```\r\n   */ async removeWatermarkFromImage(image) {\n        // Create canvas for processing\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const ctx = canvas.getContext('2d');\n        // Draw original image\n        ctx.drawImage(image, 0, 0);\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Detect watermark configuration and position\n        const config = detectWatermarkConfig(canvas.width, canvas.height);\n        const position = calculateWatermarkPosition(canvas.width, canvas.height, config);\n        // Debug logging\n        console.log('üîç Watermark Detection:', {\n            imageSize: \"\".concat(canvas.width, \"\\xd7\").concat(canvas.height),\n            watermarkSize: \"\".concat(config.logoSize, \"\\xd7\").concat(config.logoSize),\n            position: \"(\".concat(position.x, \", \").concat(position.y, \")\"),\n            margins: \"right: \".concat(config.marginRight, \"px, bottom: \").concat(config.marginBottom, \"px\")\n        });\n        // Get alpha map for this watermark size\n        const alphaMap = await this.getAlphaMap(config.logoSize);\n        // Remove watermark from image data\n        (0,_blendModes__WEBPACK_IMPORTED_MODULE_1__.removeWatermark)(imageData, alphaMap, position);\n        // Debug: Draw detection box (optional - can be enabled for debugging)\n        if ( true && window.__DEBUG_WATERMARK__) {\n            ctx.strokeStyle = '#ff0000';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(position.x, position.y, position.width, position.height);\n            console.log('üéØ Debug box drawn at watermark position');\n        }\n        // Write processed image data back to canvas\n        ctx.putImageData(imageData, 0, 0);\n        return canvas;\n    }\n    /**\r\n   * Get watermark information for display purposes\r\n   * \r\n   * Useful for showing watermark details in the UI.\r\n   * \r\n   * @param imageWidth - Image width in pixels\r\n   * @param imageHeight - Image height in pixels\r\n   * @returns Watermark information object\r\n   */ getWatermarkInfo(imageWidth, imageHeight) {\n        const config = detectWatermarkConfig(imageWidth, imageHeight);\n        const position = calculateWatermarkPosition(imageWidth, imageHeight, config);\n        return {\n            size: config.logoSize,\n            position,\n            config\n        };\n    }\n    /**\r\n   * Create new WatermarkEngine instance\r\n   * @param bgCaptures - Background capture images for alpha map calculation\r\n   */ constructor(bgCaptures){\n        this.bgCaptures = bgCaptures;\n        this.alphaMaps = {\n            48: null,\n            96: null\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29yZS93YXRlcm1hcmtFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBUThDO0FBQ0E7QUFFL0MsK0JBQStCO0FBQy9CLHVFQUF1RTtBQUN2RSxNQUFNRSxZQUFZO0FBQ2xCLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU0Msc0JBQ2RDLFVBQWtCLEVBQ2xCQyxXQUFtQjtJQUVuQiw2Q0FBNkM7SUFDN0MsSUFBSUQsYUFBYSxRQUFRQyxjQUFjLE1BQU07UUFDM0MsT0FBTztZQUNMQyxVQUFVO1lBQ1ZDLGFBQWE7WUFDYkMsY0FBYztRQUNoQjtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELElBQUlKLGFBQWEsUUFBUUMsY0FBYyxNQUFNO1FBQzNDLE9BQU87WUFDTEMsVUFBVTtZQUNWQyxhQUFhO1lBQ2JDLGNBQWM7UUFDaEI7SUFDRjtJQUVBLGlFQUFpRTtJQUNqRSxPQUFPO1FBQ0xGLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTQywyQkFDZEwsVUFBa0IsRUFDbEJDLFdBQW1CLEVBQ25CSyxNQUF1QjtJQUV2QixNQUFNLEVBQUVKLFFBQVEsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBR0U7SUFFaEQsT0FBTztRQUNMQyxHQUFHUCxhQUFhRyxjQUFjRDtRQUM5Qk0sR0FBR1AsY0FBY0csZUFBZUY7UUFDaENPLE9BQU9QO1FBQ1BRLFFBQVFSO0lBQ1Y7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1TO0lBZ0JYOzs7Ozs7OztHQVFDLEdBQ0QsYUFBYUMsU0FBbUM7UUFDOUMsTUFBTUMsT0FBTyxJQUFJQztRQUNqQixNQUFNQyxPQUFPLElBQUlEO1FBRWpCLE1BQU1FLFFBQVFDLEdBQUcsQ0FBQztZQUNoQixJQUFJRCxRQUFjLENBQUNFLFNBQVNDO2dCQUMxQk4sS0FBS08sTUFBTSxHQUFHLElBQU1GO2dCQUNwQkwsS0FBS1EsT0FBTyxHQUFHLENBQUNDO29CQUNkQyxRQUFRQyxLQUFLLENBQUMsNkJBQTZCRjtvQkFDM0NILE9BQU8sSUFBSU0sTUFBTSxpQ0FBMkMsT0FBVjVCO2dCQUNwRDtnQkFDQWdCLEtBQUthLEdBQUcsR0FBRzdCO1lBQ2I7WUFDQSxJQUFJbUIsUUFBYyxDQUFDRSxTQUFTQztnQkFDMUJKLEtBQUtLLE1BQU0sR0FBRyxJQUFNRjtnQkFDcEJILEtBQUtNLE9BQU8sR0FBRyxDQUFDQztvQkFDZEMsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QkY7b0JBQzNDSCxPQUFPLElBQUlNLE1BQU0saUNBQTJDLE9BQVYzQjtnQkFDcEQ7Z0JBQ0FpQixLQUFLVyxHQUFHLEdBQUc1QjtZQUNiO1NBQ0Q7UUFFRCxPQUFPLElBQUlhLGdCQUFnQjtZQUFFRTtZQUFNRTtRQUFLO0lBQzFDO0lBRUE7Ozs7Ozs7R0FPQyxHQUNELE1BQU1ZLFlBQVlDLElBQWEsRUFBeUI7UUFDdEQsdUNBQXVDO1FBQ3ZDLElBQUksSUFBSSxDQUFDQyxTQUFTLENBQUNELEtBQUssRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxLQUFLO1FBQzdCO1FBRUEsa0RBQWtEO1FBQ2xELE1BQU1FLFVBQVVGLFNBQVMsS0FBSyxJQUFJLENBQUNHLFVBQVUsQ0FBQ2xCLElBQUksR0FBRyxJQUFJLENBQUNrQixVQUFVLENBQUNoQixJQUFJO1FBRXpFLDBDQUEwQztRQUMxQyxNQUFNaUIsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDRixPQUFPdkIsS0FBSyxHQUFHbUI7UUFDZkksT0FBT3RCLE1BQU0sR0FBR2tCO1FBQ2hCLE1BQU1PLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztRQUM5QkQsSUFBSUUsU0FBUyxDQUFDUCxTQUFTLEdBQUc7UUFFMUIsTUFBTVEsWUFBWUgsSUFBSUksWUFBWSxDQUFDLEdBQUcsR0FBR1gsTUFBTUE7UUFFL0MsZ0NBQWdDO1FBQ2hDLE1BQU1ZLFdBQVc3Qyw0REFBaUJBLENBQUMyQztRQUNuQyxJQUFJLENBQUNULFNBQVMsQ0FBQ0QsS0FBSyxHQUFHWTtRQUV2QixPQUFPQTtJQUNUO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkMsR0FDRCxNQUFNQyx5QkFDSkMsS0FBMkMsRUFDZjtRQUM1QiwrQkFBK0I7UUFDL0IsTUFBTVYsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDRixPQUFPdkIsS0FBSyxHQUFHaUMsTUFBTWpDLEtBQUs7UUFDMUJ1QixPQUFPdEIsTUFBTSxHQUFHZ0MsTUFBTWhDLE1BQU07UUFDNUIsTUFBTXlCLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztRQUU5QixzQkFBc0I7UUFDdEJELElBQUlFLFNBQVMsQ0FBQ0ssT0FBTyxHQUFHO1FBRXhCLGlCQUFpQjtRQUNqQixNQUFNSixZQUFZSCxJQUFJSSxZQUFZLENBQUMsR0FBRyxHQUFHUCxPQUFPdkIsS0FBSyxFQUFFdUIsT0FBT3RCLE1BQU07UUFFcEUsOENBQThDO1FBQzlDLE1BQU1KLFNBQVNQLHNCQUFzQmlDLE9BQU92QixLQUFLLEVBQUV1QixPQUFPdEIsTUFBTTtRQUNoRSxNQUFNaUMsV0FBV3RDLDJCQUEyQjJCLE9BQU92QixLQUFLLEVBQUV1QixPQUFPdEIsTUFBTSxFQUFFSjtRQUV6RSxnQkFBZ0I7UUFDaEJpQixRQUFRcUIsR0FBRyxDQUFDLDJCQUEyQjtZQUNyQ0MsV0FBVyxHQUFtQmIsT0FBaEJBLE9BQU92QixLQUFLLEVBQUMsUUFBaUIsT0FBZHVCLE9BQU90QixNQUFNO1lBQzNDb0MsZUFBZSxHQUFzQnhDLE9BQW5CQSxPQUFPSixRQUFRLEVBQUMsUUFBbUIsT0FBaEJJLE9BQU9KLFFBQVE7WUFDcER5QyxVQUFVLElBQW1CQSxPQUFmQSxTQUFTcEMsQ0FBQyxFQUFDLE1BQWUsT0FBWG9DLFNBQVNuQyxDQUFDLEVBQUM7WUFDeEN1QyxTQUFTLFVBQTJDekMsT0FBakNBLE9BQU9ILFdBQVcsRUFBQyxnQkFBa0MsT0FBcEJHLE9BQU9GLFlBQVksRUFBQztRQUMxRTtRQUVBLHdDQUF3QztRQUN4QyxNQUFNb0MsV0FBVyxNQUFNLElBQUksQ0FBQ2IsV0FBVyxDQUFDckIsT0FBT0osUUFBUTtRQUV2RCxtQ0FBbUM7UUFDbkNOLDREQUFlQSxDQUFDMEMsV0FBV0UsVUFBVUc7UUFFckMsc0VBQXNFO1FBQ3RFLElBQUksS0FBNkIsSUFBSSxPQUFnQk0sbUJBQW1CLEVBQUU7WUFDeEVkLElBQUllLFdBQVcsR0FBRztZQUNsQmYsSUFBSWdCLFNBQVMsR0FBRztZQUNoQmhCLElBQUlpQixVQUFVLENBQUNULFNBQVNwQyxDQUFDLEVBQUVvQyxTQUFTbkMsQ0FBQyxFQUFFbUMsU0FBU2xDLEtBQUssRUFBRWtDLFNBQVNqQyxNQUFNO1lBQ3RFYSxRQUFRcUIsR0FBRyxDQUFDO1FBQ2Q7UUFFQSw0Q0FBNEM7UUFDNUNULElBQUlrQixZQUFZLENBQUNmLFdBQVcsR0FBRztRQUUvQixPQUFPTjtJQUNUO0lBRUE7Ozs7Ozs7O0dBUUMsR0FDRHNCLGlCQUFpQnRELFVBQWtCLEVBQUVDLFdBQW1CLEVBQWlCO1FBQ3ZFLE1BQU1LLFNBQVNQLHNCQUFzQkMsWUFBWUM7UUFDakQsTUFBTTBDLFdBQVd0QywyQkFBMkJMLFlBQVlDLGFBQWFLO1FBRXJFLE9BQU87WUFDTHNCLE1BQU10QixPQUFPSixRQUFRO1lBQ3JCeUM7WUFDQXJDO1FBQ0Y7SUFDRjtJQWxLQTs7O0dBR0MsR0FDRCxZQUFZeUIsVUFBOEIsQ0FBRTtRQUMxQyxJQUFJLENBQUNBLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRixTQUFTLEdBQUc7WUFDZixJQUFJO1lBQ0osSUFBSTtRQUNOO0lBQ0Y7QUF5SkYiLCJzb3VyY2VzIjpbIkM6XFxkZXZcXGdlbWluaS13YXRlcm1hcmstcmVtb3Zlci1tYWluXFxzcmNcXGxpYlxcY29yZVxcd2F0ZXJtYXJrRW5naW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBXYXRlcm1hcmsgRW5naW5lIC0gTWFpbiBNb2R1bGVcclxuICogQGZpbGVvdmVydmlldyBDb29yZGluYXRlcyB3YXRlcm1hcmsgZGV0ZWN0aW9uLCBhbHBoYSBtYXAgY2FsY3VsYXRpb24sIGFuZCByZW1vdmFsIG9wZXJhdGlvbnNcclxuICogQG1vZHVsZSB3YXRlcm1hcmtFbmdpbmVcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7XHJcbiAgV2F0ZXJtYXJrQ29uZmlnLFxyXG4gIFdhdGVybWFya1Bvc2l0aW9uLFxyXG4gIFdhdGVybWFya0luZm8sXHJcbiAgQmFja2dyb3VuZENhcHR1cmVzLFxyXG59IGZyb20gJ0AvdHlwZXMnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVBbHBoYU1hcCB9IGZyb20gJy4vYWxwaGFNYXAnO1xyXG5pbXBvcnQgeyByZW1vdmVXYXRlcm1hcmsgfSBmcm9tICcuL2JsZW5kTW9kZXMnO1xyXG5cclxuLy8gSW1wb3J0IGFzc2V0cyBhcyBzdGF0aWMgVVJMc1xyXG4vLyBOb3RlOiBJbiBOZXh0LmpzLCB3ZSdsbCB1c2UgZHluYW1pYyBpbXBvcnRzIGZvciBiZXR0ZXIgY29tcGF0aWJpbGl0eVxyXG5jb25zdCBCR180OF9VUkwgPSAnL2JnXzQ4LnBuZyc7XHJcbmNvbnN0IEJHXzk2X1VSTCA9ICcvYmdfOTYucG5nJztcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3Qgd2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gaW1hZ2UgZGltZW5zaW9uc1xyXG4gKiBcclxuICogR2VtaW5pJ3Mgd2F0ZXJtYXJrIHJ1bGVzOlxyXG4gKiAtIElmIGJvdGggd2lkdGggQU5EIGhlaWdodCA+IDEwMjRweCDihpIgdXNlIDk2w5c5NiB3YXRlcm1hcmtcclxuICogLSBPdGhlcndpc2Ug4oaSIHVzZSA0OMOXNDggd2F0ZXJtYXJrXHJcbiAqIFxyXG4gKiBFZGdlIGNhc2VzOlxyXG4gKiAtIFZlcnkgc21hbGwgaW1hZ2VzICg8IDIwMHB4KSBtYXkgbm90IGhhdmUgd2F0ZXJtYXJrc1xyXG4gKiAtIFdhdGVybWFyayBwb3NpdGlvbiBtYXkgdmFyeSBiYXNlZCBvbiBhc3BlY3QgcmF0aW9cclxuICogXHJcbiAqIEBwYXJhbSBpbWFnZVdpZHRoIC0gSW1hZ2Ugd2lkdGggaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSBpbWFnZUhlaWdodCAtIEltYWdlIGhlaWdodCBpbiBwaXhlbHNcclxuICogQHJldHVybnMgV2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGNvbmZpZyA9IGRldGVjdFdhdGVybWFya0NvbmZpZygxOTIwLCAxMDgwKTtcclxuICogLy8gUmV0dXJuczogeyBsb2dvU2l6ZTogOTYsIG1hcmdpblJpZ2h0OiA2NCwgbWFyZ2luQm90dG9tOiA2NCB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFdhdGVybWFya0NvbmZpZyhcclxuICBpbWFnZVdpZHRoOiBudW1iZXIsXHJcbiAgaW1hZ2VIZWlnaHQ6IG51bWJlclxyXG4pOiBXYXRlcm1hcmtDb25maWcge1xyXG4gIC8vIEZvciB2ZXJ5IGxhcmdlIGltYWdlcywgdXNlIDk2w5c5NiB3YXRlcm1hcmtcclxuICBpZiAoaW1hZ2VXaWR0aCA+IDEwMjQgJiYgaW1hZ2VIZWlnaHQgPiAxMDI0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2dvU2l6ZTogOTYsXHJcbiAgICAgIG1hcmdpblJpZ2h0OiA2NCxcclxuICAgICAgbWFyZ2luQm90dG9tOiA2NCxcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZvciBtZWRpdW0vbGFyZ2UgaW1hZ2VzIHdpdGggb25lIGRpbWVuc2lvbiA+IDEwMjRcclxuICBpZiAoaW1hZ2VXaWR0aCA+IDEwMjQgfHwgaW1hZ2VIZWlnaHQgPiAxMDI0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2dvU2l6ZTogNDgsXHJcbiAgICAgIG1hcmdpblJpZ2h0OiAzMixcclxuICAgICAgbWFyZ2luQm90dG9tOiAzMixcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZvciBzbWFsbGVyIGltYWdlcywgdXNlIHNtYWxsZXIgd2F0ZXJtYXJrIHdpdGggdGlnaHRlciBtYXJnaW5zXHJcbiAgcmV0dXJuIHtcclxuICAgIGxvZ29TaXplOiA0OCxcclxuICAgIG1hcmdpblJpZ2h0OiAyNCxcclxuICAgIG1hcmdpbkJvdHRvbTogMjQsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB3YXRlcm1hcmsgcG9zaXRpb24gaW4gaW1hZ2VcclxuICogXHJcbiAqIFRoZSB3YXRlcm1hcmsgaXMgYWx3YXlzIHBvc2l0aW9uZWQgaW4gdGhlIGJvdHRvbS1yaWdodCBjb3JuZXJcclxuICogd2l0aCBzcGVjaWZpYyBtYXJnaW5zIGJhc2VkIG9uIHRoZSB3YXRlcm1hcmsgc2l6ZS5cclxuICogXHJcbiAqIEBwYXJhbSBpbWFnZVdpZHRoIC0gSW1hZ2Ugd2lkdGggaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSBpbWFnZUhlaWdodCAtIEltYWdlIGhlaWdodCBpbiBwaXhlbHNcclxuICogQHBhcmFtIGNvbmZpZyAtIFdhdGVybWFyayBjb25maWd1cmF0aW9uXHJcbiAqIEByZXR1cm5zIFdhdGVybWFyayBwb3NpdGlvbiBvYmplY3Qgd2l0aCB4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGNvbmZpZyA9IHsgbG9nb1NpemU6IDQ4LCBtYXJnaW5SaWdodDogMzIsIG1hcmdpbkJvdHRvbTogMzIgfTtcclxuICogY29uc3QgcG9zaXRpb24gPSBjYWxjdWxhdGVXYXRlcm1hcmtQb3NpdGlvbigxOTIwLCAxMDgwLCBjb25maWcpO1xyXG4gKiAvLyBSZXR1cm5zOiB7IHg6IDE4NDAsIHk6IDEwMDAsIHdpZHRoOiA0OCwgaGVpZ2h0OiA0OCB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKFxyXG4gIGltYWdlV2lkdGg6IG51bWJlcixcclxuICBpbWFnZUhlaWdodDogbnVtYmVyLFxyXG4gIGNvbmZpZzogV2F0ZXJtYXJrQ29uZmlnXHJcbik6IFdhdGVybWFya1Bvc2l0aW9uIHtcclxuICBjb25zdCB7IGxvZ29TaXplLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tIH0gPSBjb25maWc7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpbWFnZVdpZHRoIC0gbWFyZ2luUmlnaHQgLSBsb2dvU2l6ZSxcclxuICAgIHk6IGltYWdlSGVpZ2h0IC0gbWFyZ2luQm90dG9tIC0gbG9nb1NpemUsXHJcbiAgICB3aWR0aDogbG9nb1NpemUsXHJcbiAgICBoZWlnaHQ6IGxvZ29TaXplLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXRlcm1hcmsgRW5naW5lIENsYXNzXHJcbiAqIFxyXG4gKiBQcm92aWRlcyBoaWdoLWxldmVsIEFQSSBmb3Igd2F0ZXJtYXJrIHJlbW92YWwgb3BlcmF0aW9ucy5cclxuICogTWFuYWdlcyBhbHBoYSBtYXBzLCBiYWNrZ3JvdW5kIGNhcHR1cmVzLCBhbmQgY29vcmRpbmF0ZXMgdGhlIHJlbW92YWwgcHJvY2Vzcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgZW5naW5lID0gYXdhaXQgV2F0ZXJtYXJrRW5naW5lLmNyZWF0ZSgpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmdpbmUucmVtb3ZlV2F0ZXJtYXJrRnJvbUltYWdlKGltYWdlRWxlbWVudCk7XHJcbiAqIGNvbnN0IGJsb2IgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc3VsdC50b0Jsb2IocmVzb2x2ZSwgJ2ltYWdlL3BuZycpKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2F0ZXJtYXJrRW5naW5lIHtcclxuICBwcml2YXRlIGJnQ2FwdHVyZXM6IEJhY2tncm91bmRDYXB0dXJlcztcclxuICBwcml2YXRlIGFscGhhTWFwczogUmVjb3JkPDQ4IHwgOTYsIEZsb2F0MzJBcnJheSB8IG51bGw+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IFdhdGVybWFya0VuZ2luZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSBiZ0NhcHR1cmVzIC0gQmFja2dyb3VuZCBjYXB0dXJlIGltYWdlcyBmb3IgYWxwaGEgbWFwIGNhbGN1bGF0aW9uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoYmdDYXB0dXJlczogQmFja2dyb3VuZENhcHR1cmVzKSB7XHJcbiAgICB0aGlzLmJnQ2FwdHVyZXMgPSBiZ0NhcHR1cmVzO1xyXG4gICAgdGhpcy5hbHBoYU1hcHMgPSB7XHJcbiAgICAgIDQ4OiBudWxsLFxyXG4gICAgICA5NjogbnVsbCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGF0aWMgZmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuZCBpbml0aWFsaXplIGVuZ2luZVxyXG4gICAqIFxyXG4gICAqIExvYWRzIGJhY2tncm91bmQgY2FwdHVyZSBpbWFnZXMgYXN5bmNocm9ub3VzbHkgYmVmb3JlXHJcbiAgICogY3JlYXRpbmcgdGhlIGVuZ2luZSBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbml0aWFsaXplZCBXYXRlcm1hcmtFbmdpbmVcclxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGltYWdlcyBmYWlsIHRvIGxvYWRcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKCk6IFByb21pc2U8V2F0ZXJtYXJrRW5naW5lPiB7XHJcbiAgICBjb25zdCBiZzQ4ID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb25zdCBiZzk2ID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgYmc0OC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgYmc0OC5vbmVycm9yID0gKGUpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGJnXzQ4LnBuZzonLCBlKTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGJnXzQ4LnBuZyBmcm9tICR7QkdfNDhfVVJMfWApKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJnNDguc3JjID0gQkdfNDhfVVJMO1xyXG4gICAgICB9KSxcclxuICAgICAgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGJnOTYub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgIGJnOTYub25lcnJvciA9IChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBiZ185Ni5wbmc6JywgZSk7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBiZ185Ni5wbmcgZnJvbSAke0JHXzk2X1VSTH1gKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBiZzk2LnNyYyA9IEJHXzk2X1VSTDtcclxuICAgICAgfSksXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFdhdGVybWFya0VuZ2luZSh7IGJnNDgsIGJnOTYgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3IgY2FsY3VsYXRlIGFscGhhIG1hcCBmb3Igd2F0ZXJtYXJrIHNpemVcclxuICAgKiBcclxuICAgKiBDYWNoZXMgY2FsY3VsYXRlZCBhbHBoYSBtYXBzIGZvciBwZXJmb3JtYW5jZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gc2l6ZSAtIFdhdGVybWFyayBzaXplICg0OCBvciA5NilcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBGbG9hdDMyQXJyYXkgYWxwaGEgbWFwXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0QWxwaGFNYXAoc2l6ZTogNDggfCA5Nik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XHJcbiAgICAvLyBSZXR1cm4gY2FjaGVkIGFscGhhIG1hcCBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0aGlzLmFscGhhTWFwc1tzaXplXSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hbHBoYU1hcHNbc2l6ZV0hO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbGVjdCBiYWNrZ3JvdW5kIGltYWdlIGJhc2VkIG9uIHdhdGVybWFyayBzaXplXHJcbiAgICBjb25zdCBiZ0ltYWdlID0gc2l6ZSA9PT0gNDggPyB0aGlzLmJnQ2FwdHVyZXMuYmc0OCA6IHRoaXMuYmdDYXB0dXJlcy5iZzk2O1xyXG5cclxuICAgIC8vIEV4dHJhY3QgSW1hZ2VEYXRhIGZyb20gYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSBzaXplO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHNpemU7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcbiAgICBjdHguZHJhd0ltYWdlKGJnSW1hZ2UsIDAsIDApO1xyXG5cclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGFuZCBjYWNoZSBhbHBoYSBtYXBcclxuICAgIGNvbnN0IGFscGhhTWFwID0gY2FsY3VsYXRlQWxwaGFNYXAoaW1hZ2VEYXRhKTtcclxuICAgIHRoaXMuYWxwaGFNYXBzW3NpemVdID0gYWxwaGFNYXA7XHJcblxyXG4gICAgcmV0dXJuIGFscGhhTWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHdhdGVybWFyayBmcm9tIGltYWdlXHJcbiAgICogXHJcbiAgICogTWFpbiBlbnRyeSBwb2ludCBmb3Igd2F0ZXJtYXJrIHJlbW92YWwuIEF1dG9tYXRpY2FsbHkgZGV0ZWN0c1xyXG4gICAqIHdhdGVybWFyayBjb25maWd1cmF0aW9uLCBjYWxjdWxhdGVzIHBvc2l0aW9uLCBhbmQgYXBwbGllc1xyXG4gICAqIHJldmVyc2UgYWxwaGEgYmxlbmRpbmcgdG8gcmVtb3ZlIHRoZSB3YXRlcm1hcmsuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIGltYWdlIC0gSW5wdXQgaW1hZ2UgKEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQpXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY2FudmFzIHdpdGggd2F0ZXJtYXJrIHJlbW92ZWRcclxuICAgKiBcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgZW5naW5lID0gYXdhaXQgV2F0ZXJtYXJrRW5naW5lLmNyZWF0ZSgpO1xyXG4gICAqIGNvbnN0IHByb2Nlc3NlZENhbnZhcyA9IGF3YWl0IGVuZ2luZS5yZW1vdmVXYXRlcm1hcmtGcm9tSW1hZ2UoaW1nKTtcclxuICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByb2Nlc3NlZENhbnZhcyk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgcmVtb3ZlV2F0ZXJtYXJrRnJvbUltYWdlKFxyXG4gICAgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudFxyXG4gICk6IFByb21pc2U8SFRNTENhbnZhc0VsZW1lbnQ+IHtcclxuICAgIC8vIENyZWF0ZSBjYW52YXMgZm9yIHByb2Nlc3NpbmdcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAgIC8vIERyYXcgb3JpZ2luYWwgaW1hZ2VcclxuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG5cclxuICAgIC8vIEdldCBpbWFnZSBkYXRhXHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgLy8gRGV0ZWN0IHdhdGVybWFyayBjb25maWd1cmF0aW9uIGFuZCBwb3NpdGlvblxyXG4gICAgY29uc3QgY29uZmlnID0gZGV0ZWN0V2F0ZXJtYXJrQ29uZmlnKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgY29uZmlnKTtcclxuXHJcbiAgICAvLyBEZWJ1ZyBsb2dnaW5nXHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBXYXRlcm1hcmsgRGV0ZWN0aW9uOicsIHtcclxuICAgICAgaW1hZ2VTaXplOiBgJHtjYW52YXMud2lkdGh9w5cke2NhbnZhcy5oZWlnaHR9YCxcclxuICAgICAgd2F0ZXJtYXJrU2l6ZTogYCR7Y29uZmlnLmxvZ29TaXplfcOXJHtjb25maWcubG9nb1NpemV9YCxcclxuICAgICAgcG9zaXRpb246IGAoJHtwb3NpdGlvbi54fSwgJHtwb3NpdGlvbi55fSlgLFxyXG4gICAgICBtYXJnaW5zOiBgcmlnaHQ6ICR7Y29uZmlnLm1hcmdpblJpZ2h0fXB4LCBib3R0b206ICR7Y29uZmlnLm1hcmdpbkJvdHRvbX1weGAsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZXQgYWxwaGEgbWFwIGZvciB0aGlzIHdhdGVybWFyayBzaXplXHJcbiAgICBjb25zdCBhbHBoYU1hcCA9IGF3YWl0IHRoaXMuZ2V0QWxwaGFNYXAoY29uZmlnLmxvZ29TaXplKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgd2F0ZXJtYXJrIGZyb20gaW1hZ2UgZGF0YVxyXG4gICAgcmVtb3ZlV2F0ZXJtYXJrKGltYWdlRGF0YSwgYWxwaGFNYXAsIHBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBEZWJ1ZzogRHJhdyBkZXRlY3Rpb24gYm94IChvcHRpb25hbCAtIGNhbiBiZSBlbmFibGVkIGZvciBkZWJ1Z2dpbmcpXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyBhcyBhbnkpLl9fREVCVUdfV0FURVJNQVJLX18pIHtcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZjAwMDAnO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgICAgY3R4LnN0cm9rZVJlY3QocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ud2lkdGgsIHBvc2l0aW9uLmhlaWdodCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIERlYnVnIGJveCBkcmF3biBhdCB3YXRlcm1hcmsgcG9zaXRpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXcml0ZSBwcm9jZXNzZWQgaW1hZ2UgZGF0YSBiYWNrIHRvIGNhbnZhc1xyXG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgd2F0ZXJtYXJrIGluZm9ybWF0aW9uIGZvciBkaXNwbGF5IHB1cnBvc2VzXHJcbiAgICogXHJcbiAgICogVXNlZnVsIGZvciBzaG93aW5nIHdhdGVybWFyayBkZXRhaWxzIGluIHRoZSBVSS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gaW1hZ2VXaWR0aCAtIEltYWdlIHdpZHRoIGluIHBpeGVsc1xyXG4gICAqIEBwYXJhbSBpbWFnZUhlaWdodCAtIEltYWdlIGhlaWdodCBpbiBwaXhlbHNcclxuICAgKiBAcmV0dXJucyBXYXRlcm1hcmsgaW5mb3JtYXRpb24gb2JqZWN0XHJcbiAgICovXHJcbiAgZ2V0V2F0ZXJtYXJrSW5mbyhpbWFnZVdpZHRoOiBudW1iZXIsIGltYWdlSGVpZ2h0OiBudW1iZXIpOiBXYXRlcm1hcmtJbmZvIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IGRldGVjdFdhdGVybWFya0NvbmZpZyhpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVdhdGVybWFya1Bvc2l0aW9uKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNpemU6IGNvbmZpZy5sb2dvU2l6ZSxcclxuICAgICAgcG9zaXRpb24sXHJcbiAgICAgIGNvbmZpZyxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVBbHBoYU1hcCIsInJlbW92ZVdhdGVybWFyayIsIkJHXzQ4X1VSTCIsIkJHXzk2X1VSTCIsImRldGVjdFdhdGVybWFya0NvbmZpZyIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImxvZ29TaXplIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJjYWxjdWxhdGVXYXRlcm1hcmtQb3NpdGlvbiIsImNvbmZpZyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJXYXRlcm1hcmtFbmdpbmUiLCJjcmVhdGUiLCJiZzQ4IiwiSW1hZ2UiLCJiZzk2IiwiUHJvbWlzZSIsImFsbCIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJvbmVycm9yIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwic3JjIiwiZ2V0QWxwaGFNYXAiLCJzaXplIiwiYWxwaGFNYXBzIiwiYmdJbWFnZSIsImJnQ2FwdHVyZXMiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiYWxwaGFNYXAiLCJyZW1vdmVXYXRlcm1hcmtGcm9tSW1hZ2UiLCJpbWFnZSIsInBvc2l0aW9uIiwibG9nIiwiaW1hZ2VTaXplIiwid2F0ZXJtYXJrU2l6ZSIsIm1hcmdpbnMiLCJ3aW5kb3ciLCJfX0RFQlVHX1dBVEVSTUFSS19fIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VSZWN0IiwicHV0SW1hZ2VEYXRhIiwiZ2V0V2F0ZXJtYXJrSW5mbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/core/watermarkEngine.ts\n"));

/***/ })

});