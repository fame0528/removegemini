"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_WatermarkRemover_tsx",{

/***/ "(app-pages-browser)/./src/lib/core/watermarkEngine.ts":
/*!*****************************************!*\
  !*** ./src/lib/core/watermarkEngine.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WatermarkEngine: () => (/* binding */ WatermarkEngine),\n/* harmony export */   calculateWatermarkPosition: () => (/* binding */ calculateWatermarkPosition),\n/* harmony export */   detectWatermarkConfig: () => (/* binding */ detectWatermarkConfig)\n/* harmony export */ });\n/* harmony import */ var _alphaMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alphaMap */ \"(app-pages-browser)/./src/lib/core/alphaMap.ts\");\n/* harmony import */ var _blendModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blendModes */ \"(app-pages-browser)/./src/lib/core/blendModes.ts\");\n/**\r\n * Watermark Engine - Main Module\r\n * @fileoverview Coordinates watermark detection, alpha map calculation, and removal operations\r\n * @module watermarkEngine\r\n */ \n\n// Import assets as static URLs\n// Note: In Next.js, we'll use dynamic imports for better compatibility\nconst BG_48_URL = '/bg_48.png';\nconst BG_96_URL = '/bg_96.png';\n/**\r\n * Detect watermark configuration based on image dimensions\r\n * \r\n * Gemini's watermark rules:\r\n * - If both width AND height > 1024px ‚Üí use 96√ó96 watermark\r\n * - Otherwise ‚Üí use 48√ó48 watermark\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @returns Watermark configuration object\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = detectWatermarkConfig(1920, 1080);\r\n * // Returns: { logoSize: 96, marginRight: 64, marginBottom: 64 }\r\n * ```\r\n */ function detectWatermarkConfig(imageWidth, imageHeight) {\n    if (imageWidth > 1024 && imageHeight > 1024) {\n        return {\n            logoSize: 96,\n            marginRight: 64,\n            marginBottom: 64\n        };\n    } else {\n        return {\n            logoSize: 48,\n            marginRight: 32,\n            marginBottom: 32\n        };\n    }\n}\n/**\r\n * Calculate watermark position in image\r\n * \r\n * The watermark is always positioned in the bottom-right corner\r\n * with specific margins based on the watermark size.\r\n * \r\n * @param imageWidth - Image width in pixels\r\n * @param imageHeight - Image height in pixels\r\n * @param config - Watermark configuration\r\n * @returns Watermark position object with x, y, width, height\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = { logoSize: 48, marginRight: 32, marginBottom: 32 };\r\n * const position = calculateWatermarkPosition(1920, 1080, config);\r\n * // Returns: { x: 1840, y: 1000, width: 48, height: 48 }\r\n * ```\r\n */ function calculateWatermarkPosition(imageWidth, imageHeight, config) {\n    const { logoSize, marginRight, marginBottom } = config;\n    return {\n        x: imageWidth - marginRight - logoSize,\n        y: imageHeight - marginBottom - logoSize,\n        width: logoSize,\n        height: logoSize\n    };\n}\n/**\r\n * Watermark Engine Class\r\n * \r\n * Provides high-level API for watermark removal operations.\r\n * Manages alpha maps, background captures, and coordinates the removal process.\r\n * \r\n * @example\r\n * ```typescript\r\n * const engine = await WatermarkEngine.create();\r\n * const result = await engine.removeWatermarkFromImage(imageElement);\r\n * const blob = await new Promise(resolve => result.toBlob(resolve, 'image/png'));\r\n * ```\r\n */ class WatermarkEngine {\n    /**\r\n   * Static factory method to create and initialize engine\r\n   * \r\n   * Loads background capture images asynchronously before\r\n   * creating the engine instance.\r\n   * \r\n   * @returns Promise resolving to initialized WatermarkEngine\r\n   * @throws Error if images fail to load\r\n   */ static async create() {\n        const bg48 = new Image();\n        const bg96 = new Image();\n        await Promise.all([\n            new Promise((resolve, reject)=>{\n                bg48.onload = ()=>resolve();\n                bg48.onerror = (e)=>{\n                    console.error('Failed to load bg_48.png:', e);\n                    reject(new Error(\"Failed to load bg_48.png from \".concat(BG_48_URL)));\n                };\n                bg48.src = BG_48_URL;\n            }),\n            new Promise((resolve, reject)=>{\n                bg96.onload = ()=>resolve();\n                bg96.onerror = (e)=>{\n                    console.error('Failed to load bg_96.png:', e);\n                    reject(new Error(\"Failed to load bg_96.png from \".concat(BG_96_URL)));\n                };\n                bg96.src = BG_96_URL;\n            })\n        ]);\n        return new WatermarkEngine({\n            bg48,\n            bg96\n        });\n    }\n    /**\r\n   * Get or calculate alpha map for watermark size\r\n   * \r\n   * Caches calculated alpha maps for performance.\r\n   * \r\n   * @param size - Watermark size (48 or 96)\r\n   * @returns Promise resolving to Float32Array alpha map\r\n   */ async getAlphaMap(size) {\n        // Return cached alpha map if available\n        if (this.alphaMaps[size]) {\n            return this.alphaMaps[size];\n        }\n        // Select background image based on watermark size\n        const bgImage = size === 48 ? this.bgCaptures.bg48 : this.bgCaptures.bg96;\n        // Extract ImageData from background image\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(bgImage, 0, 0);\n        const imageData = ctx.getImageData(0, 0, size, size);\n        // Calculate and cache alpha map\n        const alphaMap = (0,_alphaMap__WEBPACK_IMPORTED_MODULE_0__.calculateAlphaMap)(imageData);\n        this.alphaMaps[size] = alphaMap;\n        return alphaMap;\n    }\n    /**\r\n   * Remove watermark from image\r\n   * \r\n   * Main entry point for watermark removal. Automatically detects\r\n   * watermark configuration, calculates position, and applies\r\n   * reverse alpha blending to remove the watermark.\r\n   * \r\n   * @param image - Input image (HTMLImageElement or HTMLCanvasElement)\r\n   * @returns Promise resolving to canvas with watermark removed\r\n   * \r\n   * @example\r\n   * ```typescript\r\n * const engine = await WatermarkEngine.create();\r\n   * const processedCanvas = await engine.removeWatermarkFromImage(img);\r\n   * document.body.appendChild(processedCanvas);\r\n   * ```\r\n   */ async removeWatermarkFromImage(image) {\n        // Create canvas for processing\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const ctx = canvas.getContext('2d');\n        // Draw original image\n        ctx.drawImage(image, 0, 0);\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Detect watermark configuration and position\n        const config = detectWatermarkConfig(canvas.width, canvas.height);\n        const position = calculateWatermarkPosition(canvas.width, canvas.height, config);\n        // Debug logging\n        console.log('üîç Watermark Detection:', {\n            imageSize: \"\".concat(canvas.width, \"\\xd7\").concat(canvas.height),\n            watermarkSize: \"\".concat(config.logoSize, \"\\xd7\").concat(config.logoSize),\n            position: \"(\".concat(position.x, \", \").concat(position.y, \")\"),\n            margins: \"right: \".concat(config.marginRight, \"px, bottom: \").concat(config.marginBottom, \"px\")\n        });\n        // Get alpha map for this watermark size\n        const alphaMap = await this.getAlphaMap(config.logoSize);\n        // Remove watermark from image data\n        (0,_blendModes__WEBPACK_IMPORTED_MODULE_1__.removeWatermark)(imageData, alphaMap, position);\n        // Debug: Draw detection box (optional - can be enabled for debugging)\n        if ( true && window.__DEBUG_WATERMARK__) {\n            ctx.strokeStyle = '#ff0000';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(position.x, position.y, position.width, position.height);\n            console.log('üéØ Debug box drawn at watermark position');\n        }\n        // Write processed image data back to canvas\n        ctx.putImageData(imageData, 0, 0);\n        return canvas;\n    }\n    /**\r\n   * Get watermark information for display purposes\r\n   * \r\n   * Useful for showing watermark details in the UI.\r\n   * \r\n   * @param imageWidth - Image width in pixels\r\n   * @param imageHeight - Image height in pixels\r\n   * @returns Watermark information object\r\n   */ getWatermarkInfo(imageWidth, imageHeight) {\n        const config = detectWatermarkConfig(imageWidth, imageHeight);\n        const position = calculateWatermarkPosition(imageWidth, imageHeight, config);\n        return {\n            size: config.logoSize,\n            position,\n            config\n        };\n    }\n    /**\r\n   * Create new WatermarkEngine instance\r\n   * @param bgCaptures - Background capture images for alpha map calculation\r\n   */ constructor(bgCaptures){\n        this.bgCaptures = bgCaptures;\n        this.alphaMaps = {\n            48: null,\n            96: null\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29yZS93YXRlcm1hcmtFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBUThDO0FBQ0E7QUFFL0MsK0JBQStCO0FBQy9CLHVFQUF1RTtBQUN2RSxNQUFNRSxZQUFZO0FBQ2xCLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTQyxzQkFDZEMsVUFBa0IsRUFDbEJDLFdBQW1CO0lBRW5CLElBQUlELGFBQWEsUUFBUUMsY0FBYyxNQUFNO1FBQzNDLE9BQU87WUFDTEMsVUFBVTtZQUNWQyxhQUFhO1lBQ2JDLGNBQWM7UUFDaEI7SUFDRixPQUFPO1FBQ0wsT0FBTztZQUNMRixVQUFVO1lBQ1ZDLGFBQWE7WUFDYkMsY0FBYztRQUNoQjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTQywyQkFDZEwsVUFBa0IsRUFDbEJDLFdBQW1CLEVBQ25CSyxNQUF1QjtJQUV2QixNQUFNLEVBQUVKLFFBQVEsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBR0U7SUFFaEQsT0FBTztRQUNMQyxHQUFHUCxhQUFhRyxjQUFjRDtRQUM5Qk0sR0FBR1AsY0FBY0csZUFBZUY7UUFDaENPLE9BQU9QO1FBQ1BRLFFBQVFSO0lBQ1Y7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1TO0lBZ0JYOzs7Ozs7OztHQVFDLEdBQ0QsYUFBYUMsU0FBbUM7UUFDOUMsTUFBTUMsT0FBTyxJQUFJQztRQUNqQixNQUFNQyxPQUFPLElBQUlEO1FBRWpCLE1BQU1FLFFBQVFDLEdBQUcsQ0FBQztZQUNoQixJQUFJRCxRQUFjLENBQUNFLFNBQVNDO2dCQUMxQk4sS0FBS08sTUFBTSxHQUFHLElBQU1GO2dCQUNwQkwsS0FBS1EsT0FBTyxHQUFHLENBQUNDO29CQUNkQyxRQUFRQyxLQUFLLENBQUMsNkJBQTZCRjtvQkFDM0NILE9BQU8sSUFBSU0sTUFBTSxpQ0FBMkMsT0FBVjVCO2dCQUNwRDtnQkFDQWdCLEtBQUthLEdBQUcsR0FBRzdCO1lBQ2I7WUFDQSxJQUFJbUIsUUFBYyxDQUFDRSxTQUFTQztnQkFDMUJKLEtBQUtLLE1BQU0sR0FBRyxJQUFNRjtnQkFDcEJILEtBQUtNLE9BQU8sR0FBRyxDQUFDQztvQkFDZEMsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QkY7b0JBQzNDSCxPQUFPLElBQUlNLE1BQU0saUNBQTJDLE9BQVYzQjtnQkFDcEQ7Z0JBQ0FpQixLQUFLVyxHQUFHLEdBQUc1QjtZQUNiO1NBQ0Q7UUFFRCxPQUFPLElBQUlhLGdCQUFnQjtZQUFFRTtZQUFNRTtRQUFLO0lBQzFDO0lBRUE7Ozs7Ozs7R0FPQyxHQUNELE1BQU1ZLFlBQVlDLElBQWEsRUFBeUI7UUFDdEQsdUNBQXVDO1FBQ3ZDLElBQUksSUFBSSxDQUFDQyxTQUFTLENBQUNELEtBQUssRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxLQUFLO1FBQzdCO1FBRUEsa0RBQWtEO1FBQ2xELE1BQU1FLFVBQVVGLFNBQVMsS0FBSyxJQUFJLENBQUNHLFVBQVUsQ0FBQ2xCLElBQUksR0FBRyxJQUFJLENBQUNrQixVQUFVLENBQUNoQixJQUFJO1FBRXpFLDBDQUEwQztRQUMxQyxNQUFNaUIsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDRixPQUFPdkIsS0FBSyxHQUFHbUI7UUFDZkksT0FBT3RCLE1BQU0sR0FBR2tCO1FBQ2hCLE1BQU1PLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztRQUM5QkQsSUFBSUUsU0FBUyxDQUFDUCxTQUFTLEdBQUc7UUFFMUIsTUFBTVEsWUFBWUgsSUFBSUksWUFBWSxDQUFDLEdBQUcsR0FBR1gsTUFBTUE7UUFFL0MsZ0NBQWdDO1FBQ2hDLE1BQU1ZLFdBQVc3Qyw0REFBaUJBLENBQUMyQztRQUNuQyxJQUFJLENBQUNULFNBQVMsQ0FBQ0QsS0FBSyxHQUFHWTtRQUV2QixPQUFPQTtJQUNUO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkMsR0FDRCxNQUFNQyx5QkFDSkMsS0FBMkMsRUFDZjtRQUM1QiwrQkFBK0I7UUFDL0IsTUFBTVYsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDRixPQUFPdkIsS0FBSyxHQUFHaUMsTUFBTWpDLEtBQUs7UUFDMUJ1QixPQUFPdEIsTUFBTSxHQUFHZ0MsTUFBTWhDLE1BQU07UUFDNUIsTUFBTXlCLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztRQUU5QixzQkFBc0I7UUFDdEJELElBQUlFLFNBQVMsQ0FBQ0ssT0FBTyxHQUFHO1FBRXhCLGlCQUFpQjtRQUNqQixNQUFNSixZQUFZSCxJQUFJSSxZQUFZLENBQUMsR0FBRyxHQUFHUCxPQUFPdkIsS0FBSyxFQUFFdUIsT0FBT3RCLE1BQU07UUFFcEUsOENBQThDO1FBQzlDLE1BQU1KLFNBQVNQLHNCQUFzQmlDLE9BQU92QixLQUFLLEVBQUV1QixPQUFPdEIsTUFBTTtRQUNoRSxNQUFNaUMsV0FBV3RDLDJCQUEyQjJCLE9BQU92QixLQUFLLEVBQUV1QixPQUFPdEIsTUFBTSxFQUFFSjtRQUV6RSxnQkFBZ0I7UUFDaEJpQixRQUFRcUIsR0FBRyxDQUFDLDJCQUEyQjtZQUNyQ0MsV0FBVyxHQUFtQmIsT0FBaEJBLE9BQU92QixLQUFLLEVBQUMsUUFBaUIsT0FBZHVCLE9BQU90QixNQUFNO1lBQzNDb0MsZUFBZSxHQUFzQnhDLE9BQW5CQSxPQUFPSixRQUFRLEVBQUMsUUFBbUIsT0FBaEJJLE9BQU9KLFFBQVE7WUFDcER5QyxVQUFVLElBQW1CQSxPQUFmQSxTQUFTcEMsQ0FBQyxFQUFDLE1BQWUsT0FBWG9DLFNBQVNuQyxDQUFDLEVBQUM7WUFDeEN1QyxTQUFTLFVBQTJDekMsT0FBakNBLE9BQU9ILFdBQVcsRUFBQyxnQkFBa0MsT0FBcEJHLE9BQU9GLFlBQVksRUFBQztRQUMxRTtRQUVBLHdDQUF3QztRQUN4QyxNQUFNb0MsV0FBVyxNQUFNLElBQUksQ0FBQ2IsV0FBVyxDQUFDckIsT0FBT0osUUFBUTtRQUV2RCxtQ0FBbUM7UUFDbkNOLDREQUFlQSxDQUFDMEMsV0FBV0UsVUFBVUc7UUFFckMsc0VBQXNFO1FBQ3RFLElBQUksS0FBNkIsSUFBSSxPQUFnQk0sbUJBQW1CLEVBQUU7WUFDeEVkLElBQUllLFdBQVcsR0FBRztZQUNsQmYsSUFBSWdCLFNBQVMsR0FBRztZQUNoQmhCLElBQUlpQixVQUFVLENBQUNULFNBQVNwQyxDQUFDLEVBQUVvQyxTQUFTbkMsQ0FBQyxFQUFFbUMsU0FBU2xDLEtBQUssRUFBRWtDLFNBQVNqQyxNQUFNO1lBQ3RFYSxRQUFRcUIsR0FBRyxDQUFDO1FBQ2Q7UUFFQSw0Q0FBNEM7UUFDNUNULElBQUlrQixZQUFZLENBQUNmLFdBQVcsR0FBRztRQUUvQixPQUFPTjtJQUNUO0lBRUE7Ozs7Ozs7O0dBUUMsR0FDRHNCLGlCQUFpQnRELFVBQWtCLEVBQUVDLFdBQW1CLEVBQWlCO1FBQ3ZFLE1BQU1LLFNBQVNQLHNCQUFzQkMsWUFBWUM7UUFDakQsTUFBTTBDLFdBQVd0QywyQkFBMkJMLFlBQVlDLGFBQWFLO1FBRXJFLE9BQU87WUFDTHNCLE1BQU10QixPQUFPSixRQUFRO1lBQ3JCeUM7WUFDQXJDO1FBQ0Y7SUFDRjtJQWxLQTs7O0dBR0MsR0FDRCxZQUFZeUIsVUFBOEIsQ0FBRTtRQUMxQyxJQUFJLENBQUNBLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRixTQUFTLEdBQUc7WUFDZixJQUFJO1lBQ0osSUFBSTtRQUNOO0lBQ0Y7QUF5SkYiLCJzb3VyY2VzIjpbIkM6XFxkZXZcXGdlbWluaS13YXRlcm1hcmstcmVtb3Zlci1tYWluXFxzcmNcXGxpYlxcY29yZVxcd2F0ZXJtYXJrRW5naW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBXYXRlcm1hcmsgRW5naW5lIC0gTWFpbiBNb2R1bGVcclxuICogQGZpbGVvdmVydmlldyBDb29yZGluYXRlcyB3YXRlcm1hcmsgZGV0ZWN0aW9uLCBhbHBoYSBtYXAgY2FsY3VsYXRpb24sIGFuZCByZW1vdmFsIG9wZXJhdGlvbnNcclxuICogQG1vZHVsZSB3YXRlcm1hcmtFbmdpbmVcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7XHJcbiAgV2F0ZXJtYXJrQ29uZmlnLFxyXG4gIFdhdGVybWFya1Bvc2l0aW9uLFxyXG4gIFdhdGVybWFya0luZm8sXHJcbiAgQmFja2dyb3VuZENhcHR1cmVzLFxyXG59IGZyb20gJ0AvdHlwZXMnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVBbHBoYU1hcCB9IGZyb20gJy4vYWxwaGFNYXAnO1xyXG5pbXBvcnQgeyByZW1vdmVXYXRlcm1hcmsgfSBmcm9tICcuL2JsZW5kTW9kZXMnO1xyXG5cclxuLy8gSW1wb3J0IGFzc2V0cyBhcyBzdGF0aWMgVVJMc1xyXG4vLyBOb3RlOiBJbiBOZXh0LmpzLCB3ZSdsbCB1c2UgZHluYW1pYyBpbXBvcnRzIGZvciBiZXR0ZXIgY29tcGF0aWJpbGl0eVxyXG5jb25zdCBCR180OF9VUkwgPSAnL2JnXzQ4LnBuZyc7XHJcbmNvbnN0IEJHXzk2X1VSTCA9ICcvYmdfOTYucG5nJztcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3Qgd2F0ZXJtYXJrIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gaW1hZ2UgZGltZW5zaW9uc1xyXG4gKiBcclxuICogR2VtaW5pJ3Mgd2F0ZXJtYXJrIHJ1bGVzOlxyXG4gKiAtIElmIGJvdGggd2lkdGggQU5EIGhlaWdodCA+IDEwMjRweCDihpIgdXNlIDk2w5c5NiB3YXRlcm1hcmtcclxuICogLSBPdGhlcndpc2Ug4oaSIHVzZSA0OMOXNDggd2F0ZXJtYXJrXHJcbiAqIFxyXG4gKiBAcGFyYW0gaW1hZ2VXaWR0aCAtIEltYWdlIHdpZHRoIGluIHBpeGVsc1xyXG4gKiBAcGFyYW0gaW1hZ2VIZWlnaHQgLSBJbWFnZSBoZWlnaHQgaW4gcGl4ZWxzXHJcbiAqIEByZXR1cm5zIFdhdGVybWFyayBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBjb25maWcgPSBkZXRlY3RXYXRlcm1hcmtDb25maWcoMTkyMCwgMTA4MCk7XHJcbiAqIC8vIFJldHVybnM6IHsgbG9nb1NpemU6IDk2LCBtYXJnaW5SaWdodDogNjQsIG1hcmdpbkJvdHRvbTogNjQgfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RXYXRlcm1hcmtDb25maWcoXHJcbiAgaW1hZ2VXaWR0aDogbnVtYmVyLFxyXG4gIGltYWdlSGVpZ2h0OiBudW1iZXJcclxuKTogV2F0ZXJtYXJrQ29uZmlnIHtcclxuICBpZiAoaW1hZ2VXaWR0aCA+IDEwMjQgJiYgaW1hZ2VIZWlnaHQgPiAxMDI0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2dvU2l6ZTogOTYsXHJcbiAgICAgIG1hcmdpblJpZ2h0OiA2NCxcclxuICAgICAgbWFyZ2luQm90dG9tOiA2NCxcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxvZ29TaXplOiA0OCxcclxuICAgICAgbWFyZ2luUmlnaHQ6IDMyLFxyXG4gICAgICBtYXJnaW5Cb3R0b206IDMyLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgd2F0ZXJtYXJrIHBvc2l0aW9uIGluIGltYWdlXHJcbiAqIFxyXG4gKiBUaGUgd2F0ZXJtYXJrIGlzIGFsd2F5cyBwb3NpdGlvbmVkIGluIHRoZSBib3R0b20tcmlnaHQgY29ybmVyXHJcbiAqIHdpdGggc3BlY2lmaWMgbWFyZ2lucyBiYXNlZCBvbiB0aGUgd2F0ZXJtYXJrIHNpemUuXHJcbiAqIFxyXG4gKiBAcGFyYW0gaW1hZ2VXaWR0aCAtIEltYWdlIHdpZHRoIGluIHBpeGVsc1xyXG4gKiBAcGFyYW0gaW1hZ2VIZWlnaHQgLSBJbWFnZSBoZWlnaHQgaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSBjb25maWcgLSBXYXRlcm1hcmsgY29uZmlndXJhdGlvblxyXG4gKiBAcmV0dXJucyBXYXRlcm1hcmsgcG9zaXRpb24gb2JqZWN0IHdpdGggeCwgeSwgd2lkdGgsIGhlaWdodFxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBjb25maWcgPSB7IGxvZ29TaXplOiA0OCwgbWFyZ2luUmlnaHQ6IDMyLCBtYXJnaW5Cb3R0b206IDMyIH07XHJcbiAqIGNvbnN0IHBvc2l0aW9uID0gY2FsY3VsYXRlV2F0ZXJtYXJrUG9zaXRpb24oMTkyMCwgMTA4MCwgY29uZmlnKTtcclxuICogLy8gUmV0dXJuczogeyB4OiAxODQwLCB5OiAxMDAwLCB3aWR0aDogNDgsIGhlaWdodDogNDggfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXYXRlcm1hcmtQb3NpdGlvbihcclxuICBpbWFnZVdpZHRoOiBudW1iZXIsXHJcbiAgaW1hZ2VIZWlnaHQ6IG51bWJlcixcclxuICBjb25maWc6IFdhdGVybWFya0NvbmZpZ1xyXG4pOiBXYXRlcm1hcmtQb3NpdGlvbiB7XHJcbiAgY29uc3QgeyBsb2dvU2l6ZSwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSB9ID0gY29uZmlnO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgeDogaW1hZ2VXaWR0aCAtIG1hcmdpblJpZ2h0IC0gbG9nb1NpemUsXHJcbiAgICB5OiBpbWFnZUhlaWdodCAtIG1hcmdpbkJvdHRvbSAtIGxvZ29TaXplLFxyXG4gICAgd2lkdGg6IGxvZ29TaXplLFxyXG4gICAgaGVpZ2h0OiBsb2dvU2l6ZSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogV2F0ZXJtYXJrIEVuZ2luZSBDbGFzc1xyXG4gKiBcclxuICogUHJvdmlkZXMgaGlnaC1sZXZlbCBBUEkgZm9yIHdhdGVybWFyayByZW1vdmFsIG9wZXJhdGlvbnMuXHJcbiAqIE1hbmFnZXMgYWxwaGEgbWFwcywgYmFja2dyb3VuZCBjYXB0dXJlcywgYW5kIGNvb3JkaW5hdGVzIHRoZSByZW1vdmFsIHByb2Nlc3MuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGVuZ2luZSA9IGF3YWl0IFdhdGVybWFya0VuZ2luZS5jcmVhdGUoKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZW5naW5lLnJlbW92ZVdhdGVybWFya0Zyb21JbWFnZShpbWFnZUVsZW1lbnQpO1xyXG4gKiBjb25zdCBibG9iID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXN1bHQudG9CbG9iKHJlc29sdmUsICdpbWFnZS9wbmcnKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdhdGVybWFya0VuZ2luZSB7XHJcbiAgcHJpdmF0ZSBiZ0NhcHR1cmVzOiBCYWNrZ3JvdW5kQ2FwdHVyZXM7XHJcbiAgcHJpdmF0ZSBhbHBoYU1hcHM6IFJlY29yZDw0OCB8IDk2LCBGbG9hdDMyQXJyYXkgfCBudWxsPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBXYXRlcm1hcmtFbmdpbmUgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gYmdDYXB0dXJlcyAtIEJhY2tncm91bmQgY2FwdHVyZSBpbWFnZXMgZm9yIGFscGhhIG1hcCBjYWxjdWxhdGlvblxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGJnQ2FwdHVyZXM6IEJhY2tncm91bmRDYXB0dXJlcykge1xyXG4gICAgdGhpcy5iZ0NhcHR1cmVzID0gYmdDYXB0dXJlcztcclxuICAgIHRoaXMuYWxwaGFNYXBzID0ge1xyXG4gICAgICA0ODogbnVsbCxcclxuICAgICAgOTY6IG51bGwsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhdGljIGZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBlbmdpbmVcclxuICAgKiBcclxuICAgKiBMb2FkcyBiYWNrZ3JvdW5kIGNhcHR1cmUgaW1hZ2VzIGFzeW5jaHJvbm91c2x5IGJlZm9yZVxyXG4gICAqIGNyZWF0aW5nIHRoZSBlbmdpbmUgaW5zdGFuY2UuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW5pdGlhbGl6ZWQgV2F0ZXJtYXJrRW5naW5lXHJcbiAgICogQHRocm93cyBFcnJvciBpZiBpbWFnZXMgZmFpbCB0byBsb2FkXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSgpOiBQcm9taXNlPFdhdGVybWFya0VuZ2luZT4ge1xyXG4gICAgY29uc3QgYmc0OCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29uc3QgYmc5NiA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGJnNDgub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgIGJnNDgub25lcnJvciA9IChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBiZ180OC5wbmc6JywgZSk7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBiZ180OC5wbmcgZnJvbSAke0JHXzQ4X1VSTH1gKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBiZzQ4LnNyYyA9IEJHXzQ4X1VSTDtcclxuICAgICAgfSksXHJcbiAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBiZzk2Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICBiZzk2Lm9uZXJyb3IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgYmdfOTYucG5nOicsIGUpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgYmdfOTYucG5nIGZyb20gJHtCR185Nl9VUkx9YCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYmc5Ni5zcmMgPSBCR185Nl9VUkw7XHJcbiAgICAgIH0pLFxyXG4gICAgXSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBXYXRlcm1hcmtFbmdpbmUoeyBiZzQ4LCBiZzk2IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIGNhbGN1bGF0ZSBhbHBoYSBtYXAgZm9yIHdhdGVybWFyayBzaXplXHJcbiAgICogXHJcbiAgICogQ2FjaGVzIGNhbGN1bGF0ZWQgYWxwaGEgbWFwcyBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNpemUgLSBXYXRlcm1hcmsgc2l6ZSAoNDggb3IgOTYpXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gRmxvYXQzMkFycmF5IGFscGhhIG1hcFxyXG4gICAqL1xyXG4gIGFzeW5jIGdldEFscGhhTWFwKHNpemU6IDQ4IHwgOTYpOiBQcm9taXNlPEZsb2F0MzJBcnJheT4ge1xyXG4gICAgLy8gUmV0dXJuIGNhY2hlZCBhbHBoYSBtYXAgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy5hbHBoYU1hcHNbc2l6ZV0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWxwaGFNYXBzW3NpemVdITtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QgYmFja2dyb3VuZCBpbWFnZSBiYXNlZCBvbiB3YXRlcm1hcmsgc2l6ZVxyXG4gICAgY29uc3QgYmdJbWFnZSA9IHNpemUgPT09IDQ4ID8gdGhpcy5iZ0NhcHR1cmVzLmJnNDggOiB0aGlzLmJnQ2FwdHVyZXMuYmc5NjtcclxuXHJcbiAgICAvLyBFeHRyYWN0IEltYWdlRGF0YSBmcm9tIGJhY2tncm91bmQgaW1hZ2VcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gc2l6ZTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG4gICAgY3R4LmRyYXdJbWFnZShiZ0ltYWdlLCAwLCAwKTtcclxuXHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUsIHNpemUpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhbmQgY2FjaGUgYWxwaGEgbWFwXHJcbiAgICBjb25zdCBhbHBoYU1hcCA9IGNhbGN1bGF0ZUFscGhhTWFwKGltYWdlRGF0YSk7XHJcbiAgICB0aGlzLmFscGhhTWFwc1tzaXplXSA9IGFscGhhTWFwO1xyXG5cclxuICAgIHJldHVybiBhbHBoYU1hcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB3YXRlcm1hcmsgZnJvbSBpbWFnZVxyXG4gICAqIFxyXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHdhdGVybWFyayByZW1vdmFsLiBBdXRvbWF0aWNhbGx5IGRldGVjdHNcclxuICAgKiB3YXRlcm1hcmsgY29uZmlndXJhdGlvbiwgY2FsY3VsYXRlcyBwb3NpdGlvbiwgYW5kIGFwcGxpZXNcclxuICAgKiByZXZlcnNlIGFscGhhIGJsZW5kaW5nIHRvIHJlbW92ZSB0aGUgd2F0ZXJtYXJrLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBpbWFnZSAtIElucHV0IGltYWdlIChIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50KVxyXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGNhbnZhcyB3aXRoIHdhdGVybWFyayByZW1vdmVkXHJcbiAgICogXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGVuZ2luZSA9IGF3YWl0IFdhdGVybWFya0VuZ2luZS5jcmVhdGUoKTtcclxuICAgKiBjb25zdCBwcm9jZXNzZWRDYW52YXMgPSBhd2FpdCBlbmdpbmUucmVtb3ZlV2F0ZXJtYXJrRnJvbUltYWdlKGltZyk7XHJcbiAgICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcm9jZXNzZWRDYW52YXMpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZVdhdGVybWFya0Zyb21JbWFnZShcclxuICAgIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnRcclxuICApOiBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PiB7XHJcbiAgICAvLyBDcmVhdGUgY2FudmFzIGZvciBwcm9jZXNzaW5nXHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICAvLyBEcmF3IG9yaWdpbmFsIGltYWdlXHJcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcclxuXHJcbiAgICAvLyBHZXQgaW1hZ2UgZGF0YVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgIC8vIERldGVjdCB3YXRlcm1hcmsgY29uZmlndXJhdGlvbiBhbmQgcG9zaXRpb25cclxuICAgIGNvbnN0IGNvbmZpZyA9IGRldGVjdFdhdGVybWFya0NvbmZpZyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBjYWxjdWxhdGVXYXRlcm1hcmtQb3NpdGlvbihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIGNvbmZpZyk7XHJcblxyXG4gICAgLy8gRGVidWcgbG9nZ2luZ1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gV2F0ZXJtYXJrIERldGVjdGlvbjonLCB7XHJcbiAgICAgIGltYWdlU2l6ZTogYCR7Y2FudmFzLndpZHRofcOXJHtjYW52YXMuaGVpZ2h0fWAsXHJcbiAgICAgIHdhdGVybWFya1NpemU6IGAke2NvbmZpZy5sb2dvU2l6ZX3DlyR7Y29uZmlnLmxvZ29TaXplfWAsXHJcbiAgICAgIHBvc2l0aW9uOiBgKCR7cG9zaXRpb24ueH0sICR7cG9zaXRpb24ueX0pYCxcclxuICAgICAgbWFyZ2luczogYHJpZ2h0OiAke2NvbmZpZy5tYXJnaW5SaWdodH1weCwgYm90dG9tOiAke2NvbmZpZy5tYXJnaW5Cb3R0b219cHhgLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR2V0IGFscGhhIG1hcCBmb3IgdGhpcyB3YXRlcm1hcmsgc2l6ZVxyXG4gICAgY29uc3QgYWxwaGFNYXAgPSBhd2FpdCB0aGlzLmdldEFscGhhTWFwKGNvbmZpZy5sb2dvU2l6ZSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHdhdGVybWFyayBmcm9tIGltYWdlIGRhdGFcclxuICAgIHJlbW92ZVdhdGVybWFyayhpbWFnZURhdGEsIGFscGhhTWFwLCBwb3NpdGlvbik7XHJcblxyXG4gICAgLy8gRGVidWc6IERyYXcgZGV0ZWN0aW9uIGJveCAob3B0aW9uYWwgLSBjYW4gYmUgZW5hYmxlZCBmb3IgZGVidWdnaW5nKVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5fX0RFQlVHX1dBVEVSTUFSS19fKSB7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmYwMDAwJztcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgIGN0eC5zdHJva2VSZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLndpZHRoLCBwb3NpdGlvbi5oZWlnaHQpO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBEZWJ1ZyBib3ggZHJhd24gYXQgd2F0ZXJtYXJrIHBvc2l0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JpdGUgcHJvY2Vzc2VkIGltYWdlIGRhdGEgYmFjayB0byBjYW52YXNcclxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHdhdGVybWFyayBpbmZvcm1hdGlvbiBmb3IgZGlzcGxheSBwdXJwb3Nlc1xyXG4gICAqIFxyXG4gICAqIFVzZWZ1bCBmb3Igc2hvd2luZyB3YXRlcm1hcmsgZGV0YWlscyBpbiB0aGUgVUkuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIGltYWdlV2lkdGggLSBJbWFnZSB3aWR0aCBpbiBwaXhlbHNcclxuICAgKiBAcGFyYW0gaW1hZ2VIZWlnaHQgLSBJbWFnZSBoZWlnaHQgaW4gcGl4ZWxzXHJcbiAgICogQHJldHVybnMgV2F0ZXJtYXJrIGluZm9ybWF0aW9uIG9iamVjdFxyXG4gICAqL1xyXG4gIGdldFdhdGVybWFya0luZm8oaW1hZ2VXaWR0aDogbnVtYmVyLCBpbWFnZUhlaWdodDogbnVtYmVyKTogV2F0ZXJtYXJrSW5mbyB7XHJcbiAgICBjb25zdCBjb25maWcgPSBkZXRlY3RXYXRlcm1hcmtDb25maWcoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpO1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBjYWxjdWxhdGVXYXRlcm1hcmtQb3NpdGlvbihpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzaXplOiBjb25maWcubG9nb1NpemUsXHJcbiAgICAgIHBvc2l0aW9uLFxyXG4gICAgICBjb25maWcsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlQWxwaGFNYXAiLCJyZW1vdmVXYXRlcm1hcmsiLCJCR180OF9VUkwiLCJCR185Nl9VUkwiLCJkZXRlY3RXYXRlcm1hcmtDb25maWciLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJsb2dvU2l6ZSIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwiY2FsY3VsYXRlV2F0ZXJtYXJrUG9zaXRpb24iLCJjb25maWciLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiV2F0ZXJtYXJrRW5naW5lIiwiY3JlYXRlIiwiYmc0OCIsIkltYWdlIiwiYmc5NiIsIlByb21pc2UiLCJhbGwiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwib25lcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsInNyYyIsImdldEFscGhhTWFwIiwic2l6ZSIsImFscGhhTWFwcyIsImJnSW1hZ2UiLCJiZ0NhcHR1cmVzIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImFscGhhTWFwIiwicmVtb3ZlV2F0ZXJtYXJrRnJvbUltYWdlIiwiaW1hZ2UiLCJwb3NpdGlvbiIsImxvZyIsImltYWdlU2l6ZSIsIndhdGVybWFya1NpemUiLCJtYXJnaW5zIiwid2luZG93IiwiX19ERUJVR19XQVRFUk1BUktfXyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlUmVjdCIsInB1dEltYWdlRGF0YSIsImdldFdhdGVybWFya0luZm8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/core/watermarkEngine.ts\n"));

/***/ })

});